<!DOCTYPE html>
<html lang="en">
  <head>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125893749-1"></script>
      <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-125893749-1');
          </script>
    <title>tomland: Bidirectional TOML serialization</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Kowainik page">
    <meta name="keywords" content="Haskell, Functional progarmming, FP">
    <meta name="author" content="Kowainik" />

    <!-- Twitter cards -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@kowainik" />
    <meta property="twitter:title" content="Kowainik - tomland: Bidirectional TOML serialization" />
    <meta property="og:title" content="Kowainik - tomland: Bidirectional TOML serialization" />
    <!-- <meta property="og:description" content="..." /> -->
    <meta property="og:site_name" content="Kowainik" />
    <meta property="og:image" content="https://kowainik.github.io/images/logo_trans.png" />

    <!-- Favicon -->
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" rel="stylesheet">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/dracula.min.css" />
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css">
    <!-- Custom fonts for this template -->
    <link href="../css/font-awesome.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Plugin CSS -->
    <link href="../css/magnific-popup.css" rel="stylesheet" type="text/css">
    <!-- Custom styles for this template -->
    <link href="../css/default.css" rel="stylesheet">
    <link href="../css/post.css" rel="stylesheet">
  </head>

  <body>

          <!-- Header -->
      <nav class="navbar navbar-inverse navbar-fixed-left leftmenu bg-primary text-secondary">
            <div class="navbar-header">
                <div class="postslogo"> <a class="navbar-brand" href="../"><img class="img-fluid d-block mx-auto" src="../images/logo-tr.png" alt="Kowainik"></a></div>
            </div>
            <div class="toc-zone">
                <h6 class="coolFont">Contents</h6>

                <div class="toc">
                    <ul> <li><a href="#why-bidirectional-toml">Why bidirectional TOML?</a></li><li><a href="#core-architecture-of-tomland">Core architecture of Tomland</a></li><ul> <li><a href="#key-concepts">Key concepts</a></li><li><a href="#type-checking-toml">Type checking TOML</a></li><li><a href="#prefix-tree">Prefix tree</a></li></ul> <li><a href="#tagged-partial-bidirectional-isomorphism">Tagged partial bidirectional isomorphism</a></li><li><a href="#codec">Codec</a></li><ul> <li><a href="#monadic-profunctors">Monadic profunctors</a></li><li><a href="#toml-codec">TOML codec</a></li></ul> <li><a href="#edsl">EDSL</a></li><li><a href="#tests">Tests</a></li><li><a href="#benchmarks">Benchmarks</a></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#acknowledgment">Acknowledgment</a></li></ul>
                </div>
            </div>
            <div class="coolFont">
                <div>Date: January 14, 2019</div>

                <div class="author">Author: Dmitrii Kovanikov</div>
                <div class="row tag-block">
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/haskell">haskell</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/TOML">TOML</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/GADT">GADT</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/profunctor">profunctor</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/data structure">data structure</a></span>
                
                </div>

                <div class="allposts">
                    <h3><a href="../posts"> Posts =<< </a></h3>
                </div>
            </div>
      </nav>
      <div class="container info">
          <h2 class="text-center text-uppercase text-secondary">tomland: Bidirectional TOML serialization</h2>
          <div class="content">
          <div class="row post">
              <div class="col-12 post-body">
              <p class="lead">
                  <p><code>tomland</code> is a bidirectional TOML parsing and pretty-printing library. Bidirectional here means that the library allows to specify in one place how to convert Haskell data types to TOML format and how to parse TOML configurations to custom user types. This approach allows to eliminate one layer of bugs, specifically, when you update your data type and only single part of conversion (for example, parser) but accidentally forget to update the other one (printer). With bidirectional approach implemented in <code>tomland</code> you don’t have the chance to miss anything.</p>
<p>Here is just a quick look at how those bidirectional parsers look like in code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb1-2" title="2">    {<span class="ot"> userName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-3" title="3">    ,<span class="ot"> userAge  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" title="4">    }</a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="ot">userCodec ::</span> <span class="dt">TomlCodec</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb1-7" title="7">userCodec <span class="fu">=</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="fu">&lt;$&gt;</span> Toml.text <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> userName</a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="fu">&lt;*&gt;</span> Toml.int  <span class="st">&quot;age&quot;</span>  <span class="fu">.=</span> userAge</a></code></pre></div>
<p>You can see a bigger example in the repository README:</p>
<ul>
<li><a href="https://github.com/kowainik/tomland">kowainik/tomland</a></li>
</ul>
<p>The idea is straightforward but the implementation requires some tricks. As the result, in order to provide convenient and type-safe interfaces <code>tomland</code> uses the following non-trivial Haskell techniques:</p>
<ol type="1">
<li><strong>GADT</strong> and existential wrappers for core types and theorem-proving for more compile-time guarantees.</li>
<li>Category theory and <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Category.html">Category</a> instance for the custom data type in order to implement <a href="#tagged-partial-bidirectional-isomorphism"><strong>tagged partial bidirectional isomorphism</strong></a>.</li>
<li><strong>Monadic profunctors</strong> approach to compose those isomorphisms.</li>
<li>Custom implementation of the <strong>prefix tree</strong> specific to the structure of nested keys in TOML format.</li>
<li><strong>Property-based tests</strong> with the <a href="http://hackage.haskell.org/package/hedgehog">hedgehog</a> library that covers typeclass laws and roundtrip properties.</li>
<li>Type-safe <strong>EDSL</strong> for specifying TOML AST.</li>
</ol>
<p>Despite the fact that a lot of fancy features are used, the library is still well-tested. The whole code of the library itself contains 1600 LOC and 1100 LOC of tests in addition. But without the powerful Haskell type system, the size of such tests could be much bigger.</p>
<p>This blog post describes architecture and details of the implementation of <code>tomland</code>.</p>
<h2 id="why-bidirectional-toml"><a href="#why-bidirectional-toml">Why bidirectional TOML?</a></h2>
<p>TOML is great for static configurations. Its specification is very simple but expressive enough to cover most cases. Also, it’s unambiguous and human-readable which makes it much smoother to read and edit the configuration.</p>
<p>The state of TOML parsing libraries in the Haskell ecosystem still can be improved. There are already several libraries:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/htoml">htoml</a></li>
<li><a href="https://hackage.haskell.org/package/htoml-megaparsec">htoml-megaparsec</a></li>
<li><a href="https://hackage.haskell.org/package/toml-parser">toml-parser</a></li>
<li><a href="https://github.com/pliosoft/toml-parse">toml-parse</a></li>
<li><a href="https://hackage.haskell.org/package/toml">toml</a></li>
</ul>
<p>But not all of them have nice ways to convert TOML AST to custom Haskell types. Also, for example, <code>htoml</code> implements this conversion via <code>ToJSON/FromJSON</code> typeclasses from the <code>aeson</code> library and you might not always want to have extra dependencies if you don’t need JSON. Also, none of the libraries has pretty-printing abilities. Usually, you don’t need pretty-printing for TOML but there were at least two use-cases in my experience where I needed pretty-printing:</p>
<ol type="1">
<li><a href="https://github.com/kowainik/summoner">summoner</a>: Summoner allows to scaffold modern Haskell projects. It can read TOML configuration where you can specify some settings in advance. But for the moment, you need to write this TOML config file manually. Though there are plans to implement a feature that allows you to build your configuration settings interactively via <code>summoner</code> itself and for this we need an ability to convert <code>Settings</code> data type to TOML configuration.</li>
<li><a href="https://github.com/kowainik/life-sync">life-sync</a>: this tool allows you to sync your configs across multiple machines. It stores all tracked files in its own TOML configuration file. In order to keep this file up-to-date, <code>life-sync</code> needs not only to parse from this configuration but to convert Haskell types to TOML.</li>
</ol>
<p>I’m not going to compare TOML with JSON/YAML/Dhall, this is out of the scope for this blog post. Instead, let’s dive into library implementation details.</p>
<h2 id="core-architecture-of-tomland"><a href="#core-architecture-of-tomland">Core architecture of Tomland</a></h2>
<h3 id="key-concepts"><a href="#key-concepts">Key concepts</a></h3>
<p>Below I’m going to mention key architecture decisions behind <code>tomland</code>:</p>
<ol type="1">
<li>Function-based approach for description of how to convert Haskell data types to/from TOML instead of typeclasses-based approach. This approach has a lot of pleasant advantages for decoding libraries: no orphan instances and no ambiguity when there are multiple options for conversion. Here <code>tomland</code> goes in one line with libraries like <a href="http://hackage.haskell.org/package/hedgehog">hedgehog</a>, <a href="http://hackage.haskell.org/package/sv">sv</a> and <a href="http://hackage.haskell.org/package/waargonaut">waargonaut</a>.</li>
<li>Two-phase approach: parsing (from text to intermediate AST) and decoding (from AST to custom user types). The similar way for pretty-printing.</li>
<li>Make invalid states unrepresentable: TOML supports arrays of values. But TOML specification also forbids to have heterogeneous arrays. This is captured at the compile time by <code>tomland</code>.</li>
<li>Parser combinators for parsing: <code>tomland</code> uses modern parsing library <a href="http://hackage.haskell.org/package/megaparsec">megaparsec</a>.</li>
</ol>
<h3 id="type-checking-toml"><a href="#type-checking-toml">Type checking TOML</a></h3>
<p>It was mentioned at the beginning that <code>tomland</code> uses <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts">GADT</a> to represent AST. Let’s look at this part closer. When you want to convert unstructured runtime data to GADT in Haskell you have to use 2-step approach:</p>
<ol type="1">
<li>Parse this data to plain old ADT.</li>
<li>Type check simple ADT to GADT.</li>
</ol>
<p>TOML has several primitive types, but let’s just consider <code>Integer</code>, <code>Text</code> and <code>Array</code> for simplicity. Here is how ADT for untyped representation of TOML values looks like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">UValue</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="fu">=</span> <span class="dt">UInteger</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="fu">|</span> <span class="dt">UText</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="fu">|</span> <span class="dt">UArray</span> [<span class="dt">UValue</span>]</a></code></pre></div>
<p>And here is GADT version of this data type, that guarantees that all elements of the array have the same type (it uses extensions <code>-XDataKinds</code> and <code>-XGADTs</code>):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">TValue</span> <span class="fu">=</span> <span class="dt">TInteger</span> <span class="fu">|</span> <span class="dt">TText</span> <span class="fu">|</span> <span class="dt">TArray</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">data</span> <span class="dt">Value</span> (<span class="ot">t ::</span> <span class="dt">TValue</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="dt">Integer</span><span class="ot"> ::</span> <span class="dt">Integer</span>   <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="dt">'TInteger</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="dt">Text</span><span class="ot">    ::</span> <span class="dt">Text</span>      <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="dt">'TText</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="dt">Array</span><span class="ot">   ::</span> [<span class="dt">Value</span> t] <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="dt">'TArray</span></a></code></pre></div>
<p>Let’s assume, that we have already implemented a parser for <code>UValue</code> (instead of assuming you can also look <a href="https://github.com/kowainik/tomland/tree/master/src/Toml/Parser">at the real code</a>). Now we need to convert <code>UValue</code> to <code>Value</code>. But it’s not that simple: (1) this operation can fail and (2) in compile-time we don’t know the type of resulted <code>Value</code>.</p>
<p>To overcome the second challenge, we need to introduce an existential wrapper around <code>Value</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">AnyValue</span> <span class="fu">=</span> <span class="kw">forall</span> (<span class="ot">t ::</span> <span class="dt">TValue</span>) <span class="fu">.</span> <span class="dt">AnyValue</span> (<span class="dt">Value</span> t)</a></code></pre></div>
<blockquote>
<p><strong>NOTE</strong>: you can’t return <code>Value t</code> from the function but you can return <code>AnyValue</code> since the type variable <code>t</code> is hidden inside <code>AnyValue</code> constructor.</p>
</blockquote>
<p>Our conversion function can fail only because of a single reason: when elements of <code>UArray</code> field have different constructors. The algorithm to check that all elements of the list have the same type is the following:</p>
<ol type="1">
<li>Pattern match on the list. If the list is empty then this is a valid array.</li>
<li>If the list is not empty then we assume that the type of the first element is the expected type of the whole array. So we just need to check every element of the list against this first element and ensure that all of them have the same type. But this needs to be done carefully in order to convince GHC that we checked everything properly.</li>
</ol>
<p>First, let’s implement the <code>sameValue</code> function that checks whether two <code>Value</code>s have the same type. Here we’re going to use <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html#t::-126-:">propositional equality</a> which is implemented in the following way:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">data</span> a <span class="fu">:~:</span> b <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="fu">:~:</span> a</a></code></pre></div>
<p>And here is <code>sameValue</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">TypeMismatchError</span> <span class="fu">=</span> <span class="dt">TypeMismatchError</span></a>
<a class="sourceLine" id="cb6-2" title="2">  {<span class="ot"> typeExpected ::</span> <span class="dt">TValue</span></a>
<a class="sourceLine" id="cb6-3" title="3">  ,<span class="ot"> typeActual   ::</span> <span class="dt">TValue</span></a>
<a class="sourceLine" id="cb6-4" title="4">  }</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ot">valueType ::</span> <span class="dt">Value</span> t <span class="ot">-&gt;</span> <span class="dt">TValue</span></a>
<a class="sourceLine" id="cb6-7" title="7">valueType (<span class="dt">Integer</span> _) <span class="fu">=</span> <span class="dt">TInteger</span></a>
<a class="sourceLine" id="cb6-8" title="8">valueType (<span class="dt">Text</span> _)    <span class="fu">=</span> <span class="dt">TText</span></a>
<a class="sourceLine" id="cb6-9" title="9">valueType (<span class="dt">Array</span> _)   <span class="fu">=</span> <span class="dt">TArray</span></a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="ot">sameValue ::</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeMismatchError</span> (a <span class="fu">:~:</span> b)</a>
<a class="sourceLine" id="cb6-12" title="12">sameValue <span class="dt">Integer</span>{} <span class="dt">Integer</span>{} <span class="fu">=</span> <span class="dt">Right</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-13" title="13">sameValue <span class="dt">Text</span>{}    <span class="dt">Text</span>{}    <span class="fu">=</span> <span class="dt">Right</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-14" title="14">sameValue <span class="dt">Array</span>{}   <span class="dt">Array</span>{}   <span class="fu">=</span> <span class="dt">Right</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-15" title="15">sameValue l         r         <span class="fu">=</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">TypeMismatchError</span></a>
<a class="sourceLine" id="cb6-16" title="16">                                         { typeExpected <span class="fu">=</span> valueType l</a>
<a class="sourceLine" id="cb6-17" title="17">                                         , typeActual   <span class="fu">=</span> valueType r</a>
<a class="sourceLine" id="cb6-18" title="18">                                         }</a></code></pre></div>
<p>Now we’re ready to implement the proper simple type checking algorithm!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">typeCheck ::</span> <span class="dt">UValue</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeMismatchError</span> <span class="dt">AnyValue</span></a>
<a class="sourceLine" id="cb7-2" title="2">typeCheck (<span class="dt">UInteger</span> n) <span class="fu">=</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">AnyValue</span> <span class="fu">$</span> <span class="dt">Integer</span> n</a>
<a class="sourceLine" id="cb7-3" title="3">typeCheck (<span class="dt">UText</span> s)    <span class="fu">=</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">AnyValue</span> <span class="fu">$</span> <span class="dt">Text</span> s</a>
<a class="sourceLine" id="cb7-4" title="4">typeCheck (<span class="dt">UArray</span> a)   <span class="fu">=</span> <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-5" title="5">    []   <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">AnyValue</span> <span class="fu">$</span> <span class="dt">Array</span> []  <span class="co">-- empty list is valid array</span></a>
<a class="sourceLine" id="cb7-6" title="6">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="dt">AnyValue</span> v <span class="ot">&lt;-</span> typeCheck x  <span class="co">-- type check first element of array</span></a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="dt">AnyValue</span> <span class="fu">.</span> <span class="dt">Array</span> <span class="fu">&lt;$&gt;</span> checkElem v xs  <span class="co">-- check `xs` against `v`</span></a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="ot">    checkElem ::</span> <span class="dt">Value</span> t <span class="ot">-&gt;</span> [<span class="dt">UValue</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeMismatchError</span> [<span class="dt">Value</span> t]</a>
<a class="sourceLine" id="cb7-11" title="11">    checkElem v []     <span class="fu">=</span> <span class="dt">Right</span> [v]  <span class="co">-- no values = no problems</span></a>
<a class="sourceLine" id="cb7-12" title="12">    checkElem v (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="dt">AnyValue</span> vx <span class="ot">&lt;-</span> typeCheck x</a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="dt">Refl</span> <span class="ot">&lt;-</span> sameValue v vx</a>
<a class="sourceLine" id="cb7-15" title="15">        (v <span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> checkElem vx xs</a></code></pre></div>
<p>In order to convince GHC that elements of the array have the same type, we pattern match on <code>Refl</code>. After this pattern matching GHC can see type equality between given element and the head of the list. That’s why we can put them in the same list.</p>
<h3 id="prefix-tree"><a href="#prefix-tree">Prefix tree</a></h3>
<p>We managed to deal only with values. But in TOML values assigned to textual keys. Here is some TOML example:</p>
<pre class="toml"><code>server.id    = 42
server.host  = &quot;best-haskell-blog.com&quot;
server.ports = [8080, 8081, 9080, 9081]</code></pre>
<p>Here <code>server.ports</code> is a key and it has a value of the array of integers. Keys are represented in the following way in <code>tomland</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">newtype</span> <span class="dt">Piece</span> <span class="fu">=</span> <span class="dt">Piece</span> {<span class="ot"> unPiece ::</span> <span class="dt">Text</span> }</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">newtype</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">Key</span> {<span class="ot"> unKey ::</span> <span class="dt">NonEmpty</span> <span class="dt">Piece</span> }</a></code></pre></div>
<p>Keys in TOML are dot-separated words. If some keys share common prefix they semantically belong to the same object (though you don’t have to follow this rule, it helps readability a lot). TOML also has tables that help to visually separate parts of the static configuration. Here is an example of tables and nested tables:</p>
<pre class="toml"><code>[server]
    [server.production]
        id    = 42
        host  = &quot;best-haskell-blog.com&quot;
        ports = [8080, 8081]
    [server.staging]
        id    = 777
        host  = &quot;okayish-haskell-blog.com&quot;
        ports = [9080, 9081]</code></pre>
<p>To represent this structure nicely we need some prefix tree. There’re several libraries on Hackage that implement very decent prefix trees but unfortunately, none of them fits our use-case. So we decided to implement our own data structure. It has the following shape using two mutually recursive data structures:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">type</span> <span class="dt">Prefix</span> <span class="fu">=</span> <span class="dt">Key</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">type</span> <span class="dt">PrefixMap</span> a <span class="fu">=</span> <span class="dt">HashMap</span> <span class="dt">Piece</span> (<span class="dt">PrefixTree</span> a)</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">data</span> <span class="dt">PrefixTree</span> a</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Key</span> a</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="fu">|</span> <span class="dt">Branch</span> <span class="dt">Prefix</span> (<span class="dt">Maybe</span> a) (<span class="dt">PrefixMap</span> a)</a></code></pre></div>
<p>When we want to insert a new key into <code>PrefixTree</code> we need to split given key and key inside the current tree node into common and remaining parts and then split the current node properly. The result of finding key prefixes is captured by the following data type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">KeysDiff</span></a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="fu">=</span> <span class="dt">Equal</span>      <span class="co">-- ^ Keys are equal.</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="fu">|</span> <span class="dt">NoPrefix</span>   <span class="co">-- ^ Keys don't have any common part.</span></a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="fu">|</span> <span class="dt">FstIsPref</span>  <span class="co">-- ^ The first key is the prefix of the second one.</span></a>
<a class="sourceLine" id="cb12-5" title="5">        <span class="fu">!</span><span class="dt">Key</span>     <span class="co">-- ^ Rest of the second key.</span></a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="fu">|</span> <span class="dt">SndIsPref</span>  <span class="co">-- ^ The second key is the prefix of the first one.</span></a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="fu">!</span><span class="dt">Key</span>     <span class="co">-- ^ Rest of the first key.</span></a>
<a class="sourceLine" id="cb12-8" title="8">    <span class="fu">|</span> <span class="dt">Diff</span>       <span class="co">-- ^ Keys have a common prefix.</span></a>
<a class="sourceLine" id="cb12-9" title="9">        <span class="fu">!</span><span class="dt">Key</span>     <span class="co">-- ^ Common prefix.</span></a>
<a class="sourceLine" id="cb12-10" title="10">        <span class="fu">!</span><span class="dt">Key</span>     <span class="co">-- ^ Rest of the first key.</span></a>
<a class="sourceLine" id="cb12-11" title="11">        <span class="fu">!</span><span class="dt">Key</span>     <span class="co">-- ^ Rest of the second key.</span></a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co">-- | Takes two keys and returns their difference.</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="ot">keysDiff ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">KeysDiff</span></a></code></pre></div>
<p>Every TOML configuration stores the following items:</p>
<ol type="1">
<li>Top-level keys.</li>
<li>Zero or more tables.</li>
<li>Zero or more array of tables.</li>
</ol>
<p>The structure of TOML is recursive. So every table and array of tables has the same structure. That’s why TOML AST is represented in the following way:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">data</span> <span class="dt">TOML</span> <span class="fu">=</span> <span class="dt">TOML</span></a>
<a class="sourceLine" id="cb13-2" title="2">    {<span class="ot"> tomlPairs       ::</span> <span class="dt">HashMap</span> <span class="dt">Key</span> <span class="dt">AnyValue</span></a>
<a class="sourceLine" id="cb13-3" title="3">    ,<span class="ot"> tomlTables      ::</span> <span class="dt">PrefixMap</span> <span class="dt">TOML</span></a>
<a class="sourceLine" id="cb13-4" title="4">    ,<span class="ot"> tomlTableArrays ::</span> <span class="dt">HashMap</span> <span class="dt">Key</span> (<span class="dt">NonEmpty</span> <span class="dt">TOML</span>)</a>
<a class="sourceLine" id="cb13-5" title="5">    }</a></code></pre></div>
<p>That’s all regarding TOML AST! The following sections of this tutorial cover bidirectional conversion aspect of the library.</p>
<h2 id="tagged-partial-bidirectional-isomorphism"><a href="#tagged-partial-bidirectional-isomorphism">Tagged partial bidirectional isomorphism</a></h2>
<p>First, we need to learn how to switch between basic Haskell types and <code>AnyValue</code> in both directions. Converting from <code>Text</code> to <code>AnyValue</code> is pretty simple. Just apply <code>Text</code> constructor of <code>Value</code> and then wrap into <code>AnyValue</code>. However, conversion from <code>AnyValue</code> to <code>Text</code> may fail because there might be a different constructor. Turns out that conversion to <code>AnyValue</code> also may fail. Consider <code>ByteString</code>: in order to convert <code>ByteString</code> to <code>AnyValue</code> you first need to convert it to <code>Text</code> and this operation may fail. Alternatively, you can convert <code>ByteString</code> to the array of integers.</p>
<p>You can see now that we need a way to convert types in both directions. Just like isomorphisms, but conversion in both directions may fail. Thus it’s partial. And we also want to tell our users good error messages. So this is actually <em>tagged partial bidirectional isomorphism</em>. In <code>tomland</code> this concept is captured by the following data type with a much shorter name:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">data</span> <span class="dt">BiMap</span> e a b <span class="fu">=</span> <span class="dt">BiMap</span></a>
<a class="sourceLine" id="cb14-2" title="2">    {<span class="ot"> forward  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> e b</a>
<a class="sourceLine" id="cb14-3" title="3">    ,<span class="ot"> backward ::</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span> e a</a>
<a class="sourceLine" id="cb14-4" title="4">    }</a></code></pre></div>
<p>If we look at types as sets of values then <code>BiMap</code> can be represented by the following graph:</p>
<figure>
<img src="https://user-images.githubusercontent.com/4276606/50770531-b6a36000-1298-11e9-9528-caae87951d2a.png" alt="BiMap illustration" /><figcaption>BiMap illustration</figcaption>
</figure>
<p>Type parameters <code>a</code> and <code>b</code> represent values between which we’re converting. And <code>e</code> is the type of error.</p>
<blockquote>
<p>In <code>tomland</code> <code>BiMap</code> is specialized to the following error type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">data</span> <span class="dt">TomlBiMapError</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="fu">=</span> <span class="dt">WrongConstructor</span> <span class="dt">Text</span> <span class="dt">Text</span>  <span class="co">-- expected vs. actual</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="fu">|</span> <span class="dt">WrongValue</span> <span class="dt">MatchError</span></a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="fu">|</span> <span class="dt">ArbitraryError</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb15-5" title="5"></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="kw">type</span> <span class="dt">TomlBiMap</span> <span class="fu">=</span> <span class="dt">BiMap</span> <span class="dt">TomlBiMapError</span></a></code></pre></div>
</blockquote>
<p>When we want to write bidirectional mapping between <code>Text</code> and <code>AnyValue</code> we need to provide two functions. If we want to do the same for <code>ByteString</code> and <code>AnyValue</code> we can implement the similar two functions. But you may notice that the logic for the <code>Text</code> converter is the subset of the logic for the <code>ByteString</code> converter.</p>
<p>Turns out, that <code>BiMap</code> composes very nicely! And we can write only <code>BiMap</code> between <code>ByteString</code> and <code>Text</code> and compose it with <code>BiMap</code> between <code>Text</code> and <code>AnyValue</code>. This is possible thanks to the following <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Category.html"><code>Category</code></a> instance for <code>BiMap</code> because <code>BiMap</code> forms category. <code>Category</code> allows to compose objects of type <code>Type -&gt; Type -&gt; Type</code> but for that, you need to implement the composition operator and identity object which is a neutral element for composition.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">BiMap</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="ot">    id ::</span> <span class="dt">BiMap</span> e a a</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="fu">id</span> <span class="fu">=</span> <span class="dt">BiMap</span> <span class="dt">Right</span> <span class="dt">Right</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="ot">    (.) ::</span> <span class="dt">BiMap</span> e b c <span class="ot">-&gt;</span> <span class="dt">BiMap</span> e a b <span class="ot">-&gt;</span> <span class="dt">BiMap</span> e a c</a>
<a class="sourceLine" id="cb16-6" title="6">    bc <span class="fu">.</span> ab <span class="fu">=</span> <span class="dt">BiMap</span></a>
<a class="sourceLine" id="cb16-7" title="7">        { forward  <span class="fu">=</span>  forward ab <span class="fu">&gt;=&gt;</span>  forward bc</a>
<a class="sourceLine" id="cb16-8" title="8">        , backward <span class="fu">=</span> backward bc <span class="fu">&gt;=&gt;</span> backward ab</a>
<a class="sourceLine" id="cb16-9" title="9">        }</a></code></pre></div>
<p>This instance can be clearly described by the following picture:</p>
<figure>
<img src="https://user-images.githubusercontent.com/4276606/50771234-13a01580-129b-11e9-93da-6c5dd0f7f160.png" alt="Category composition illustration" /><figcaption>Category composition illustration</figcaption>
</figure>
<p>It’s not convenient to use the dot-operator from <code>Control.Category</code> to compose <code>BiMap</code>s because this operator is already specialized to arrow <code>(-&gt;)</code> in <code>Prelude</code>. But we still can use operators <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code> for composing objects and this is quite nice!</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">_ByteStringText ::</span> <span class="dt">TomlBiMap</span> <span class="dt">ByteString</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="ot">_Text           ::</span> <span class="dt">TomlBiMap</span> <span class="dt">Text</span>       <span class="dt">AnyValue</span></a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="ot">_ByteString     ::</span> <span class="dt">TomlBiMap</span> <span class="dt">ByteString</span> <span class="dt">AnyValue</span></a>
<a class="sourceLine" id="cb17-5" title="5">_ByteString <span class="fu">=</span> _ByteStringText <span class="fu">&gt;&gt;&gt;</span> _Text</a></code></pre></div>
<p><code>tomland</code> implements a lot of <code>BiMap</code> combinators out-of-the-box for you so you should be able to avoid writing your own mini-tomland inside your application if you want to use it on common data structures.</p>
<h2 id="codec"><a href="#codec">Codec</a></h2>
<p>At this moment we can convert between primitive types and TOML values. But usually, in Haskell, we work with a lot of custom data types, including both product and sum types. This section covers how to compose different <code>BiMap</code> into a single bidirectional converter for a Haskell data type.</p>
<p>The idea for bidirectional converters is not new. It’s based on the approach called <em>monadic profunctors</em> and described in details in this blog post:</p>
<ul>
<li><a href="https://blog.poisson.chat/posts/2016-10-12-bidirectional-serialization.html">Towards monadic bidirectional serialization</a></li>
<li><a href="https://blog.poisson.chat/posts/2017-01-01-monadic-profunctors.html">Monadic profunctors for bidirectional programming</a></li>
</ul>
<p>And there is the <code>codec</code> library which implements this approach for <code>aeson</code> and <code>binary</code>:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/codec">Hackage/codec</a></li>
</ul>
<p><code>tomland</code> uses the same idea but different connecting pieces and expands this approach to support sum types, not only record types.</p>
<h3 id="monadic-profunctors"><a href="#monadic-profunctors">Monadic profunctors</a></h3>
<p>Here is the core <code>Codec</code> type for bidirectional conversion:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">data</span> <span class="dt">Codec</span> r w c a <span class="fu">=</span> <span class="dt">Codec</span></a>
<a class="sourceLine" id="cb18-2" title="2">    {<span class="ot"> codecRead  ::</span> r a</a>
<a class="sourceLine" id="cb18-3" title="3">    ,<span class="ot"> codecWrite ::</span> c <span class="ot">-&gt;</span> w a</a>
<a class="sourceLine" id="cb18-4" title="4">    }</a></code></pre></div>
<p>It looks scary but I will try to explain its meaning.</p>
<ul>
<li><code>r</code> is usually some <code>Reader</code> monad. It stores intermediate AST representation inside the context which we’re going to query to fetch pieces of our big custom user type.</li>
<li><code>w</code> is some <code>Writer</code> or <code>State</code> which stores the result of converting a current piece of custom user type to intermediate AST.</li>
<li><code>a</code> is the type that we’re converting. For example, <code>Integer</code>, <code>Text</code> or <code>Person</code>.</li>
<li><code>c</code> is a fake type variable which is required in order to make this magic works. It should be equal to <code>a</code> but if we make it <code>a</code> immediately in the type definition we won’t be able to write required instances.</li>
</ul>
<p><code>Codec</code> has <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>Alternative</code> and <code>Profunctor</code> instances.</p>
<blockquote>
<p><strong>NOTE:</strong> <code>Profunctor</code> instance is not implemented in <code>tomland</code> because, currently, it requires to add <a href="https://hackage.haskell.org/package/profunctors">profunctors</a> package to dependencies; this makes <code>tomland</code> heavier but it’s not that necessary to have this instance, it’s enough to just have functions from this instance, so we can wait until <code>Profunctor</code> migrates to <code>base</code>. There is an open GHC ticket for this:</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/ticket/16173#ticket">ghc/trac/16173</a></li>
</ul>
</blockquote>
<p>The type of <code>codecWrite</code> semantically should be equivalent to <code>a -&gt; w ()</code>: we take a value of our type <code>a</code>, change the context and ignore the result. But if we do so, we’re not able to implement a convenient interface that we want.</p>
<p>Another way to look at <code>Codec</code>: it is just a special case of <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Product.html">Product</a> monad. Here is a quick reminder of what <code>Product</code> data type is:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">data</span> <span class="dt">Product</span> f g a <span class="fu">=</span> <span class="dt">Pair</span> (f a) (g a)</a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">instance</span> (<span class="dt">Monad</span> f, <span class="dt">Monad</span> g) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Product</span> f g) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="dt">Pair</span> m n <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Pair</span> (m <span class="fu">&gt;&gt;=</span> fstP <span class="fu">.</span> f) (n <span class="fu">&gt;&gt;=</span> sndP <span class="fu">.</span> f)</a>
<a class="sourceLine" id="cb19-5" title="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-6" title="6">        fstP (<span class="dt">Pair</span> a _) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb19-7" title="7">        sndP (<span class="dt">Pair</span> _ b) <span class="fu">=</span> b</a></code></pre></div>
<p>So <code>Codec</code> semantically equivalent to the following <code>Product</code> specialization:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">type</span> <span class="dt">Codec</span> r w c a <span class="fu">=</span> <span class="dt">Product</span> r (<span class="dt">ReaderT</span> c w) a</a></code></pre></div>
<p><code>Product</code> stores two monadic actions and performs operations over them in parallel. So at one step of <code>&gt;&gt;=</code> it changes both monads. But changes are parallel, they are independent. This means, that you can describe two monadic actions in a single place but later you can choose to work only with one of them.</p>
<p>It’s an interesting and not that difficult exercise to implement <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> instances for <code>Codec</code>. So let’s look closer at <code>dimap</code> from profunctor part:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">dimap</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> r, <span class="dt">Functor</span> w)</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="ot">=&gt;</span> (c <span class="ot">-&gt;</span> d)       <span class="co">-- ^ Mapper for consumer</span></a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)       <span class="co">-- ^ Mapper for producer</span></a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Codec</span> r w d a  <span class="co">-- ^ Source 'Codec' object</span></a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Codec</span> r w c b  <span class="co">-- ^ Target ‘Codec’ object</span></a>
<a class="sourceLine" id="cb21-7" title="7">dimap f g codec <span class="fu">=</span> <span class="dt">Codec</span></a>
<a class="sourceLine" id="cb21-8" title="8">  { codecRead  <span class="fu">=</span> g <span class="fu">&lt;$&gt;</span> codecRead codec</a>
<a class="sourceLine" id="cb21-9" title="9">  , codecWrite <span class="fu">=</span> <span class="fu">fmap</span> g <span class="fu">.</span> codecWrite codec <span class="fu">.</span> f</a>
<a class="sourceLine" id="cb21-10" title="10">  }</a></code></pre></div>
<p>In real life we’re going to substitute <code>a</code> in place of <code>c</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">type</span> <span class="dt">BiCodec</span> r w a <span class="fu">=</span> <span class="dt">Codec</span> r w a a</a></code></pre></div>
<p>So simpler version of <code>dimap</code> for <code>BiCodec</code> looks like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">dimap</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> r, <span class="dt">Functor</span> w)</a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb23-4" title="4">    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb23-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">BiCodec</span> r w a</a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">BiCodec</span> r w b</a>
<a class="sourceLine" id="cb23-7" title="7">dimap f g codec <span class="fu">=</span> <span class="dt">Codec</span></a>
<a class="sourceLine" id="cb23-8" title="8">  { codecRead  <span class="fu">=</span> g <span class="fu">&lt;$&gt;</span> codecRead codec</a>
<a class="sourceLine" id="cb23-9" title="9">  , codecWrite <span class="fu">=</span> <span class="fu">fmap</span> g <span class="fu">.</span> codecWrite codec <span class="fu">.</span> f</a>
<a class="sourceLine" id="cb23-10" title="10">  }</a></code></pre></div>
<p>Now the idea behind <code>Profunctor</code> became much clearer! If we have a bidirectional converter for a value of type <code>a</code> and we have two pure functions to convert from <code>a</code> to <code>b</code> and vice versa we can have a bidirectional converter for <code>b</code>.</p>
<p>There’s only single important piece left: convenient operator to compose different <code>Codec</code>s:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">infixl</span> <span class="dv">5</span> <span class="fu">.=</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ot">(.=) ::</span> <span class="dt">Codec</span> r w field a <span class="ot">-&gt;</span> (object <span class="ot">-&gt;</span> field) <span class="ot">-&gt;</span> <span class="dt">Codec</span> r w object a</a>
<a class="sourceLine" id="cb24-3" title="3">codec <span class="fu">.=</span> getter <span class="fu">=</span> codec { codecWrite <span class="fu">=</span> codecWrite codec <span class="fu">.</span> getter }</a></code></pre></div>
<p>Attentive reader may notice that <code>(.=)</code> operator is <a href="https://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor.html#v:lmap">lmap</a> from <code>Profunctor</code> typeclass.</p>
<h3 id="toml-codec"><a href="#toml-codec">TOML codec</a></h3>
<p>We covered only general data type but it’s beneficial for understanding to see how it is specialized to write bidirectional codecs for TOML:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">DecodeException</span> (<span class="dt">Reader</span> <span class="dt">TOML</span>)</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="kw">type</span> <span class="dt">St</span> <span class="fu">=</span> <span class="dt">MaybeT</span> (<span class="dt">State</span> <span class="dt">TOML</span>)</a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">type</span> <span class="dt">TomlCodec</span> <span class="fu">=</span> <span class="dt">BiCodec</span> <span class="dt">Env</span> <span class="dt">St</span></a></code></pre></div>
<p>Our <code>r</code> variable stores TOML AST inside the context and can return an error. So <code>r a</code> in <code>Codec</code> specializes to:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">codecRead <span class="fu">@</span><span class="ot">tomland ::</span> <span class="dt">TOML</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">DecodeException</span> a</a></code></pre></div>
<p>And <code>St</code> stores produced TOML in context. All monadic actions will insert keys inside this AST and later it can be converted to just <code>Text</code>. So it’s equivalent to the following type:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1">codecWrite <span class="fu">@</span><span class="ot">tomland ::</span> a <span class="ot">-&gt;</span> <span class="dt">TOML</span> <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> a, <span class="dt">TOML</span>)</a></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> <code>TOML</code> data type from <code>tomland</code> implements <code>Semigroup</code> and <code>Monoid</code> instances, so we could use <code>Writer</code> monad instead of <code>State</code>. But it’s <a href="https://blog.infinitenegativeutility.com/2016/7/writer-monads-and-space-leaks">more efficient to use <code>State</code></a>.</p>
</blockquote>
<p>Now we need a function that can lift <code>TomlBiMap</code> to <code>TomlCodec</code>. But this function requires the key. It will lookup <code>TOML</code> AST to find <code>AnyValue</code> under given <code>Key</code> and then it will try to convert <code>AnyValue</code> according to given <code>BiMap</code>. This function is called simply <code>match</code> in <code>tomland</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">match ::</span> <span class="dt">TomlBiMap</span> a <span class="dt">AnyValue</span> <span class="ot">-&gt;</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">TomlCodec</span> a</a></code></pre></div>
<p>Now we can write helper functions to make the interface easier to work with:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="ot">integer ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">TomlCodec</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb29-2" title="2">integer <span class="fu">=</span> match _Integer</a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="ot">text ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">TomlCodec</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb29-5" title="5">text <span class="fu">=</span> match _Text</a>
<a class="sourceLine" id="cb29-6" title="6"></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="ot">arrayOf ::</span> <span class="dt">TomlBiMap</span> a <span class="dt">AnyValue</span> <span class="ot">-&gt;</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">TomlCodec</span> [a]</a>
<a class="sourceLine" id="cb29-8" title="8">arrayOf <span class="fu">=</span> match <span class="fu">.</span> _Array</a></code></pre></div>
<p>Note how we managed to decompose the problem of finding value under a key and converting this value to Haskell type into two separate problems. <code>BiMap</code> takes care of all errors during conversion between types and doesn’t know anything about TOML and keys. And <code>match</code> doesn’t know what value we’re working with (because of parametric polymorphism), all it does is just lookups required key inside the map and handles cases whether the key is found or not. For pretty-printing <code>match</code> inserts the value under the given key.</p>
<p>Tables in TOML can be used to represent codecs for the nested data structures. Remember the example with <code>production</code> and <code>staging</code> TOML server? Here is how <code>Codec</code> for this data type looks like:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">data</span> <span class="dt">Settings</span> <span class="fu">=</span> <span class="dt">Settings</span></a>
<a class="sourceLine" id="cb30-2" title="2">    {<span class="ot"> settingsId    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb30-3" title="3">    ,<span class="ot"> settingsHost  ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb30-4" title="4">    ,<span class="ot"> settingsPorts ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb30-5" title="5">    }</a>
<a class="sourceLine" id="cb30-6" title="6"></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="ot">settingsCodec ::</span> <span class="dt">TomlCodec</span> <span class="dt">Settings</span></a>
<a class="sourceLine" id="cb30-8" title="8">settingsCodec <span class="fu">=</span> <span class="dt">Settings</span></a>
<a class="sourceLine" id="cb30-9" title="9">    <span class="fu">&lt;$&gt;</span> Toml.int               <span class="st">&quot;id&quot;</span>    <span class="fu">.=</span> settingsId</a>
<a class="sourceLine" id="cb30-10" title="10">    <span class="fu">&lt;*&gt;</span> Toml.text              <span class="st">&quot;host&quot;</span>  <span class="fu">.=</span> settingsHost</a>
<a class="sourceLine" id="cb30-11" title="11">    <span class="fu">&lt;*&gt;</span> Toml.arrayOf Toml._Int <span class="st">&quot;ports&quot;</span> <span class="fu">.=</span> settingsPorts</a>
<a class="sourceLine" id="cb30-12" title="12"></a>
<a class="sourceLine" id="cb30-13" title="13"><span class="kw">data</span> <span class="dt">ServerConfig</span> <span class="fu">=</span> <span class="dt">ServerConfig</span></a>
<a class="sourceLine" id="cb30-14" title="14">    {<span class="ot"> serverConfigProduction ::</span> <span class="dt">Settings</span></a>
<a class="sourceLine" id="cb30-15" title="15">    ,<span class="ot"> serverConfigStaging    ::</span> <span class="dt">Settings</span></a>
<a class="sourceLine" id="cb30-16" title="16">    }</a>
<a class="sourceLine" id="cb30-17" title="17"></a>
<a class="sourceLine" id="cb30-18" title="18"><span class="ot">serverConfigCodec ::</span> <span class="dt">TomlCodec</span> <span class="dt">ServerConfig</span></a>
<a class="sourceLine" id="cb30-19" title="19">serverConfigCodec <span class="fu">=</span> <span class="fu">flip</span> Toml.table <span class="st">&quot;server&quot;</span> <span class="fu">$</span> <span class="dt">ServerConfig</span></a>
<a class="sourceLine" id="cb30-20" title="20">    <span class="fu">&lt;$&gt;</span> Toml.table settingsCodec <span class="st">&quot;production&quot;</span> <span class="fu">.=</span> settingsProduction</a>
<a class="sourceLine" id="cb30-21" title="21">    <span class="fu">&lt;*&gt;</span> Toml.table settingsCodec <span class="st">&quot;staging&quot;</span>    <span class="fu">.=</span> settingsStaging</a></code></pre></div>
<p>You may see that most of the time we’re using <code>Applicative</code> instance of <code>Codec</code> despite the fact that approach is called <em>monadic profunctors</em>. But turns out that applicative functors are more convenient here. Though, of course, you can do a lot of fun with <code>Monad</code> instance as well. For example, configuration can contain a field with a key name like <code>spec-version</code> and the value of this field determines how this particular configuration should be parsed.</p>
<p>And here is a couple of examples with possible error messages:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1">ghci<span class="fu">&gt;</span> showRes <span class="fu">=</span> <span class="fu">either</span> <span class="fu">print</span> <span class="fu">print</span></a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3">ghci<span class="fu">&gt;</span> showRes <span class="fu">$</span> decode (arrayOf _Int <span class="st">&quot;a&quot;</span>) <span class="st">&quot;a = [2, 'foo']&quot;</span></a>
<a class="sourceLine" id="cb31-4" title="4">tomland decode <span class="fu">error:</span>  <span class="dt">Parse</span> <span class="fu">error</span> during conversion from <span class="dt">TOML</span> to custom user <span class="kw">type</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb31-5" title="5">  <span class="dv">1</span><span class="fu">:</span><span class="dv">9</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb31-6" title="6">  <span class="fu">|</span></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="dv">1</span> <span class="fu">|</span> a <span class="fu">=</span> [<span class="dv">2</span>, 'foo']</a>
<a class="sourceLine" id="cb31-8" title="8">  <span class="fu">|</span>         <span class="fu">^</span></a>
<a class="sourceLine" id="cb31-9" title="9">unexpected <span class="ch">'''</span></a>
<a class="sourceLine" id="cb31-10" title="10">expecting <span class="ch">','</span>, <span class="ch">']'</span>, <span class="fu">or</span> integer</a>
<a class="sourceLine" id="cb31-11" title="11"></a>
<a class="sourceLine" id="cb31-12" title="12">ghci<span class="fu">&gt;</span> showRes <span class="fu">$</span> decode (arrayOf _Int <span class="st">&quot;b&quot;</span>) <span class="st">&quot;a = [2, 3]&quot;</span></a>
<a class="sourceLine" id="cb31-13" title="13">tomland decode <span class="fu">error:</span>  <span class="dt">Key</span> b is <span class="fu">not</span> found</a>
<a class="sourceLine" id="cb31-14" title="14"></a>
<a class="sourceLine" id="cb31-15" title="15">ghci<span class="fu">&gt;</span> showRes <span class="fu">$</span> decode (arrayOf _Int <span class="st">&quot;a&quot;</span>) <span class="st">&quot;a = [2, 3]&quot;</span></a>
<a class="sourceLine" id="cb31-16" title="16">[<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb31-17" title="17"></a>
<a class="sourceLine" id="cb31-18" title="18">ghci<span class="fu">&gt;</span> showRes <span class="fu">$</span> decode (arrayOf _Int <span class="st">&quot;a&quot;</span>) <span class="st">&quot;a = ['foo', 'bar']&quot;</span></a>
<a class="sourceLine" id="cb31-19" title="19">tomland decode <span class="fu">error:</span>  <span class="dt">Invalid</span> constructor</a>
<a class="sourceLine" id="cb31-20" title="20">  <span class="fu">*</span> <span class="dt">Expected</span><span class="fu">:</span> <span class="dt">TInteger</span></a>
<a class="sourceLine" id="cb31-21" title="21">  <span class="fu">*</span> <span class="dt">Actual</span><span class="fu">:</span>   <span class="dt">Text</span> <span class="st">&quot;foo&quot;</span></a></code></pre></div>
<h2 id="edsl"><a href="#edsl">EDSL</a></h2>
<p>As an additional flavour, <code>tomland</code> has the implementation of EDSL for specifying TOML objects. The implementation is very short.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">type</span> <span class="dt">TDSL</span> <span class="fu">=</span> <span class="dt">State</span> <span class="dt">TOML</span> ()</a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="ot">mkToml ::</span> <span class="dt">TDSL</span> <span class="ot">-&gt;</span> <span class="dt">TOML</span></a>
<a class="sourceLine" id="cb32-4" title="4">mkToml env <span class="fu">=</span> execState env <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb32-5" title="5"></a>
<a class="sourceLine" id="cb32-6" title="6"><span class="ot">(=:) ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">TDSL</span></a>
<a class="sourceLine" id="cb32-7" title="7">(<span class="fu">=:</span>) k v <span class="fu">=</span> modify <span class="fu">$</span> insertKeyVal k v</a>
<a class="sourceLine" id="cb32-8" title="8"></a>
<a class="sourceLine" id="cb32-9" title="9"><span class="ot">table ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">TDSL</span> <span class="ot">-&gt;</span> <span class="dt">TDSL</span></a>
<a class="sourceLine" id="cb32-10" title="10">table k <span class="fu">=</span> modify <span class="fu">.</span> insertTable k <span class="fu">.</span> mkToml</a></code></pre></div>
<p>However, we need a couple of extra instances to make API more convenient to work with. Due to the fact that our <code>Value</code> is GADT, we can implement type-safe instances for sum types!</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">instance</span> (t <span class="fu">~</span> <span class="dt">'TInteger</span>) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">Value</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" title="2">    (<span class="dt">Integer</span> a) <span class="fu">+</span> (<span class="dt">Integer</span> b) <span class="fu">=</span> <span class="dt">Integer</span> <span class="fu">$</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb33-3" title="3">    (<span class="dt">Integer</span> a) <span class="fu">*</span> (<span class="dt">Integer</span> b) <span class="fu">=</span> <span class="dt">Integer</span> <span class="fu">$</span> a <span class="fu">*</span> b</a>
<a class="sourceLine" id="cb33-4" title="4">    <span class="fu">abs</span> (<span class="dt">Integer</span> a) <span class="fu">=</span> <span class="dt">Integer</span> (<span class="fu">abs</span> a)</a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="fu">signum</span> (<span class="dt">Integer</span> a) <span class="fu">=</span> <span class="dt">Integer</span> (<span class="fu">signum</span> a)</a>
<a class="sourceLine" id="cb33-6" title="6">    <span class="fu">fromInteger</span> <span class="fu">=</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb33-7" title="7">    <span class="fu">negate</span> (<span class="dt">Integer</span> a) <span class="fu">=</span> <span class="dt">Integer</span> (<span class="fu">negate</span> a)</a>
<a class="sourceLine" id="cb33-8" title="8"></a>
<a class="sourceLine" id="cb33-9" title="9"><span class="kw">instance</span> (t <span class="fu">~</span> <span class="dt">'TText</span>) <span class="ot">=&gt;</span> <span class="dt">IsString</span> (<span class="dt">Value</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-10" title="10">    fromString <span class="fu">=</span> <span class="dt">Text</span> <span class="fu">.</span> fromString <span class="fu">@</span><span class="dt">Text</span></a></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> Here we’re using <a href="https://chrisdone.com/posts/haskell-constraint-trick"><em>type equality constraint trick</em></a> in order to provide better type inference.</p>
</blockquote>
<p>With these tools we’re able to specify TOML files in a safer way:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">serverToml ::</span> <span class="dt">TOML</span></a>
<a class="sourceLine" id="cb34-2" title="2">serverToml <span class="fu">=</span> table <span class="st">&quot;server&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb34-3" title="3">    table <span class="st">&quot;production&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb34-4" title="4">        <span class="st">&quot;id&quot;</span>    <span class="fu">=:</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb34-5" title="5">        <span class="st">&quot;host&quot;</span>  <span class="fu">=:</span> <span class="st">&quot;best-haskell-blog.com&quot;</span></a>
<a class="sourceLine" id="cb34-6" title="6">        <span class="st">&quot;ports&quot;</span> <span class="fu">=:</span> <span class="dt">Array</span> [<span class="dv">8080</span>, <span class="dv">8081</span>]</a>
<a class="sourceLine" id="cb34-7" title="7">    table “staging” <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb34-8" title="8">        <span class="st">&quot;id&quot;</span>    <span class="fu">=:</span> <span class="dv">777</span></a>
<a class="sourceLine" id="cb34-9" title="9">        <span class="st">&quot;host&quot;</span>  <span class="fu">=:</span> <span class="st">&quot;okayish-haskell-blog.com&quot;</span></a>
<a class="sourceLine" id="cb34-10" title="10">        <span class="st">&quot;ports&quot;</span> <span class="fu">=:</span> <span class="dt">Array</span> [<span class="dv">9080</span>, <span class="dv">9081</span>]</a></code></pre></div>
<p>This is very useful for testing where you want to test conversion but you don’t want to deal with parsing. With EDSL you can create TOML AST which is guaranteed to be correct and safe by construction.</p>
<h2 id="tests"><a href="#tests">Tests</a></h2>
<p>You may notice that <code>tomland</code> was written with the help of a lot of heavy tools. But types don’t substitute tests, so we have <strong>A LOT</strong> of them. I will shortly describe what we test in <code>tomland</code> to ensure you that we care very much about the correctness of this library. <code>tomland</code> is already used in production and in commercial projects so it’s necessary to have reliable tests.</p>
<ol type="1">
<li>Unit tests for parsing. TOML specification is relatively small, but still, there’re a lot of things to keep an eye on it. We have ~600 LOC of unit tests for parsing only. And we test not only that we properly parse correct TOML but we also test that we don’t parse incorrect TOML.</li>
<li>Unit tests for <code>PrefixTree</code> on <code>lookup</code> and <code>insert</code></li>
<li>Property tests for <code>PrefixTree</code> on <code>insert</code> with <code>lookup</code></li>
<li>Property tests for <code>PrefixTree</code> for <code>Semigroup</code> laws.</li>
<li>Property tests for TOML on <code>Semigroup</code> and <code>Monoid</code> laws.</li>
<li>Roundtrip property tests for parsing and printing TOML AST.</li>
<li>Roundtrip property tests for decoding and encoding TOML.</li>
<li>Roundtrip property tests for every <code>BiMap</code>.</li>
<li>Golden unit tests for pretty-printing.</li>
</ol>
<h2 id="benchmarks"><a href="#benchmarks">Benchmarks</a></h2>
<p>And we also have benchmarks to compare with other libraries! Not all libraries are still maintained. That’s why there are some difficulties to build them on newer GHC versions, so <code>tomland</code> is compared only with <code>htoml</code>, <code>htoml-megaparsec</code> and <code>toml-parser</code>. Here is the performance table:</p>
<table>
<thead>
<tr class="header">
<th>Library</th>
<th>parse :: Text -&gt; AST</th>
<th>transform :: AST -&gt; Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>tomland</td>
<td>387.5 μs</td>
<td>1.313 μs</td>
</tr>
<tr class="even">
<td>htoml</td>
<td>801.2 μs</td>
<td>32.54 μs</td>
</tr>
<tr class="odd">
<td>htoml-megaparsec</td>
<td>318.7 μs</td>
<td>34.74 μs</td>
</tr>
<tr class="even">
<td>toml-parser</td>
<td>157.2 μs</td>
<td>1.156 μs</td>
</tr>
</tbody>
</table>
<p>You may see that <code>tomland</code> is not the fastest one (though still very fast). But performance hasn’t been optimized so far and:</p>
<ol type="1">
<li><code>toml-parser</code> doesn’t support the array of tables and because of that it’s hardly possible to specify the list of custom data types in TOML with this library.</li>
<li><code>tomland</code> supports latest TOML spec while <code>htoml</code> and <code>htoml-megaparsec</code> don’t have support for all types, values and formats.</li>
<li><code>tomland</code> is the only library that has pretty-printing.</li>
<li><code>toml-parser</code> doesn’t have ways to convert TOML AST to custom Haskell types and <code>htoml*</code> libraries use typeclasses-based approach via <code>aeson</code> library.</li>
<li><code>tomland</code> is bidirectional :)</li>
</ol>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>I hope that this blog post helps you to understand better some advanced topics and Haskell in general. You can see how very different pieces of Haskell can be combined inside a single library and help to come up with the better architecture. Probably you can borrow some ideas for your next library. Or even give <code>tomland</code> a try for static configuration in your application!</p>
<h2 id="acknowledgment"><a href="#acknowledgment">Acknowledgment</a></h2>
<p>I want to say special thanks to <a href="https://github.com/vrom911">vrom911</a>, <a href="https://github.com/willbasky">willbasky</a>, <a href="https://github.com/jiegillet">jiegillet</a> and <a href="https://github.com/ghallak">ghallak</a> for massive help with <code>tomland</code> library! Their contribution is invaluable.</p>
              </p>
              </div>
          </div>
          </div>


      </div>


      <!-- Bootstrap core JavaScript -->
      <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"> </script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
      <script src="https://cdn.rawgit.com/icons8/bower-webicon/v0.10.7/jquery-webicon.min.js"></script>
      <script>hljs.initHighlightingOnLoad()</script>
      <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/contrib/auto-render.min.js"></script>
      <script async defer src="https://buttons.github.io/buttons.js"></script>
  </body>
</html>
