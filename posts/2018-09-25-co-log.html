<!DOCTYPE html>
<html lang="en">
  <head>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125893749-1"></script>
      <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-125893749-1');
          </script>
    <title>co-log: Composable Contravariant Combinatorial Comonadic Configurable Convenient Logging</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Kowainik page">
    <meta name="keywords" content="Haskell, Functional progarmming, FP">
    <meta name="author" content="Kowainik" />

    <!-- Twitter cards -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@kowainik" />
    <meta property="twitter:title" content="Kowainik - co-log: Composable Contravariant Combinatorial Comonadic Configurable Convenient Logging" />
    <meta property="og:title" content="Kowainik - co-log: Composable Contravariant Combinatorial Comonadic Configurable Convenient Logging" />
    <!-- <meta property="og:description" content="..." /> -->
    <meta property="og:site_name" content="Kowainik" />
    <meta property="og:image" content="https://kowainik.github.io/images/logo_trans.png" />

    <!-- Favicon -->
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" rel="stylesheet">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/dracula.min.css" />
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css">
    <!-- Custom fonts for this template -->
    <link href="../css/font-awesome.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Plugin CSS -->
    <link href="../css/magnific-popup.css" rel="stylesheet" type="text/css">
    <!-- Custom styles for this template -->
    <link href="../css/default.css" rel="stylesheet">
    <link href="../css/post.css" rel="stylesheet">
  </head>

  <body>

          <!-- Header -->
      <nav class="navbar navbar-inverse navbar-fixed-left leftmenu bg-primary text-secondary">
            <div class="navbar-header">
                <div class="postslogo"> <a class="navbar-brand" href="../"><img class="img-fluid d-block mx-auto" src="../images/logo-tr.png" alt="Kowainik"></a></div>
            </div>
            <div class="toc-zone">
                <h6 class="coolFont">Contents</h6>

                <div class="toc">
                    <ul> <li><a href="#introduction">Introduction</a></li><li><a href="#logaction">LogAction</a></li><ul> <li><a href="#data-type">Data type</a></li><li><a href="#how-to-use-it">How to use it?</a></li></ul> <li><a href="#composable">Composable</a></li><ul> <li><a href="#semigroup">Semigroup</a></li><li><a href="#monoid">Monoid</a></li></ul> <li><a href="#contravariant-functors">Contravariant functors</a></li><ul> <li><a href="#contravariant">Contravariant</a></li><ul> <li><a href="#map">map</a></li><li><a href="#filter">filter</a></li><li><a href="#bind">bind</a></li></ul> <li><a href="#divisible">Divisible</a></li><li><a href="#decidable">Decidable</a></li></ul> <li><a href="#combinators">Combinators</a></li><li><a href="#comonads">Comonads</a></li><li><a href="#configurable-convenient">Configurable & Convenient</a></li><li><a href="#conclusion-unexplored-opportunities">Conclusion & unexplored opportunities</a></li><li><a href="#acknowledgement">Acknowledgement</a></li></ul>
                </div>
            </div>
            <div class="coolFont">
                <div>Date: September 25, 2018</div>

                <div class="author">Author: Dmitrii Kovanikov</div>
                <div class="row tag-block">
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/haskell.html">haskell</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/logging.html">logging</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/contravariant.html">contravariant</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/comonad.html">comonad</a></span>
                
                </div>

                <div class="allposts">
                    <h3><a href="../posts.html"> Posts =<< </a></h3>
                </div>
            </div>
      </nav>
      <div class="container info">
          <h2 class="text-center text-uppercase text-secondary">co-log: Composable Contravariant Combinatorial Comonadic Configurable Convenient Logging</h2>
          <div class="content">
          <div class="row post">
              <div class="col-12 post-body">
              <p class="lead">
                  <p>This blog post illustrates the architecture of the <code>co-log</code> library: a composable Haskell logging library that explores an alternative way of logging. I’m not going to cover how to implement the <a href="https://www.elastic.co/">ElasticSearch</a> backend for the logging library or how to make concurrent logging fast. Instead, the blog post explains the core ideas of the new design. I’m going to describe in details and with examples how one can build a flexible, extensible and configurable logging framework using different parts of Haskell — from monad transformers and contravariant functors to comonads and type-level programming with dependent types.</p>
<p>If you want to go straight to the library’s source code, you can follow the link below:</p>
<ul>
<li><a href="https://github.com/kowainik/co-log">kowainik/co-log</a></li>
</ul>
<h2 id="introduction"><a href="#introduction">Introduction</a></h2>
<p>There are already several logging frameworks within the Haskell ecosystem and every library has its own idea and architecture:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/katip">katip</a></li>
<li><a href="http://hackage.haskell.org/package/monad-logger">monad-logger</a></li>
<li><a href="http://hackage.haskell.org/package/hslogger">hslogger</a></li>
<li><a href="http://hackage.haskell.org/package/log-warper">log-warper</a></li>
<li><a href="http://hackage.haskell.org/package/log-base">log-base</a></li>
<li><a href="http://hackage.haskell.org/package/logging-effect">logging-effect</a></li>
<li><a href="http://hackage.haskell.org/package/di">di</a></li>
</ul>
<p>So you might ask, why create another library? The motivation behind <code>co-log</code> is to explore a new strategy that allows having a composable and combinatorial logging library that is easy to extend and use. This is achieved by decomposing the logging task into smaller pieces:</p>
<ul>
<li>What to log: text, message data type, JSON</li>
<li>Where to log: to the terminal, to some file, to an external service</li>
<li>How to format the output: coloured text or JSON</li>
<li>How to log: with logger rotation, only to stderr or something else</li>
<li>What context to work in: pure or some IO</li>
<li>How to change context: append logs to in-memory storage or change filesystem</li>
</ul>
<p>The <code>co-log</code> framework is currently split into two packages:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/co-log-core">co-log-core</a>: lightweight library with core data types and basic combinators</li>
<li><a href="http://hackage.haskell.org/package/co-log">co-log</a>: implementation of a logging library based on <code>co-log-core</code></li>
</ul>
<p>In the following sections, I’m going to describe the main ideas behind these two packages alongside with some implementation details.</p>
<h2 id="logaction"><a href="#logaction">LogAction</a></h2>
<p>This section introduces the fundamental piece in the <code>co-log</code> design: the <code>LogAction</code> data type.</p>
<h3 id="data-type"><a href="#data-type">Data type</a></h3>
<p>The main piece of the <code>co-log</code> logging library is the following structure:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">LogAction</span> m msg <span class="fu">=</span> <span class="dt">LogAction</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    {<span class="ot"> unLogAction ::</span> msg <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    }</a></code></pre></div>
<p>This is a wrapper around a simple function. It has two type variables:</p>
<ul>
<li><code>m</code>: monad in which the logging is happening</li>
<li><code>msg</code>: the logging message itself</li>
</ul>
<p><code>LogAction</code> specifies the type of message you want to log and the context in which you want to perform the logging. So you can tune and configure your action (or, even better: create a compound action by combining smaller pieces) and use it later.</p>
<p>Here is an example of a very straightforward action:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">logStringStdout ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">logStringStdout <span class="fu">=</span> <span class="dt">LogAction</span> putStrLn</a></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> For simplicity purposes this blog post uses <code>String</code> data type for logging. In practice, it’s better to use <code>Text</code> or <code>ByteString</code> data types instead of <code>String</code> as they provide better performance. Even better, you can use Backpack and implement a general interface around <a href="https://github.com/haskell-backpack/backpack-str">backpack-str</a> package.</p>
</blockquote>
<h3 id="how-to-use-it"><a href="#how-to-use-it">How to use it?</a></h3>
<p>Once you’ve created <code>LogAction</code>, you need to use it in your application. There are multiple ways to use <code>LogAction</code> in your code since it’s just a value:</p>
<ul>
<li>Pass it as an argument to your functions explicitly each time</li>
<li>Use <a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html">Handle design pattern</a> and store <code>LogAction</code> there</li>
<li>Store it in a separate <code>ReaderT</code> layer</li>
<li>Store it in your own <code>ReaderT</code> environment</li>
<li>Use an extensible-effects library like <a href="http://hackage.haskell.org/package/freer-simple">freer-simple</a></li>
<li>Use <a href="https://github.com/int-index/caps">caps</a> framework</li>
<li>Etc.</li>
</ul>
<p>Every solution has its own advantages and drawbacks. That’s why the <code>LogAction</code> data type is in the <code>co-log-core</code> package: so it’s possible to experiment with different approaches and use the main concepts of the <code>co-log</code> library without bringing extra dependencies to your project.</p>
<p>The blog post uses the following approach supported by <code>co-log</code>.</p>
<p>First, let’s introduce a newtype wrapper around <code>ReaderT</code> that stores <code>LogAction</code> in its own environment:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">LoggerT</span> msg m a <span class="fu">=</span> <span class="dt">LoggerT</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    {<span class="ot"> runLoggerT ::</span> <span class="dt">ReaderT</span> (<span class="dt">LogAction</span> (<span class="dt">LoggerT</span> msg m) msg) m a</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    } <span class="kw">deriving</span> ( <span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadIO</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">               , <span class="dt">MonadReader</span> (<span class="dt">LogAction</span> (<span class="dt">LoggerT</span> msg m) msg)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">               )</a></code></pre></div>
<p>This data type looks scary but the idea is simple: it just stores <code>LogAction msg m</code> in the <code>ReaderT</code> environment.</p>
<p>The <code>co-log-core</code> package also has its own lens-like <code>HasLog</code> typeclass that allows to get and set <code>LogAction</code> in your environment (so you can just add <code>LogAction</code> to your <code>ReaderT</code> context instead of using <code>LoggerT</code> monad transformer):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasLog</span> env msg m <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">    getLogAction ::</span> env <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m msg</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">    setLogAction ::</span> <span class="dt">LogAction</span> m msg <span class="ot">-&gt;</span> env <span class="ot">-&gt;</span> env</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">HasLog</span> (<span class="dt">LogAction</span> m msg) msg m <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    getLogAction <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    setLogAction <span class="fu">=</span> const</a></code></pre></div>
<p>Now we can write a function that logs messages using <code>LogAction</code> from the context:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithLog</span> env msg m <span class="fu">=</span> (<span class="dt">MonadReader</span> env m, <span class="dt">HasLog</span> env msg m)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">logMsg ::</span> forall msg env m <span class="fu">.</span> <span class="dt">WithLog</span> env msg m <span class="ot">=&gt;</span> msg <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">logMsg msg <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="dt">LogAction</span> log <span class="ot">&lt;-</span> asks getLogAction</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    log msg</a></code></pre></div>
<p>We now need some way to execute actions with logging:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">usingLoggerT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">LogAction</span> m msg <span class="ot">-&gt;</span> <span class="dt">LoggerT</span> msg m a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>After implementing <code>usingLoggerT</code> we can now play with our logging framework.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">WithLog</span> env <span class="dt">String</span> m <span class="ot">=&gt;</span> m ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">example <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    logMsg “<span class="dt">Starting</span> application<span class="fu">...</span>”</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    logMsg “<span class="dt">Finishing</span> application<span class="fu">...</span>”</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">main <span class="fu">=</span> usingLoggerT logStringStdout example</a></code></pre></div>
<p>And the output is exactly what we expected:</p>
<pre class="shell"><code>Starting application...
Finishing application...</code></pre>
<h2 id="composable"><a href="#composable">Composable</a></h2>
<h3 id="semigroup"><a href="#semigroup">Semigroup</a></h3>
<p>Let’s see how to make our <code>LogAction</code> composable. Currently, we have only one action that prints <code>String</code> to <code>stdout</code>. What if we also want to print the same <code>String</code> to <code>stderr</code> in addition? Or to some file? Of course, we can create a separate <code>LogAction</code> that does just that:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">logStringBoth ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">logStringBoth <span class="fu">=</span> <span class="dt">LogAction</span> <span class="fu">$</span> \msg <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    putStrLn msg</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    hPutStrLn stderr msg</a></code></pre></div>
<p>We start to notice a pattern: we often want to perform multiple actions over a single message. This is where <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Semigroup"><code>Semigroup</code></a> comes in:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">LogAction</span> m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    (&lt;&gt;) ::</span> <span class="dt">LogAction</span> m a <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="dt">LogAction</span> action1 <span class="fu">&lt;&gt;</span> <span class="dt">LogAction</span> action2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">        <span class="dt">LogAction</span> <span class="fu">$</span> \a <span class="ot">-&gt;</span> action1 a <span class="fu">*&gt;</span> action2 a</a></code></pre></div>
<p>So instead of manually specifying what we want to do on every message, we can create our <code>LogAction</code> by combining different smaller and independent pieces.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">logStringStdout ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">logStringStdout <span class="fu">=</span> <span class="dt">LogAction</span> putStrLn</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">logStringStderr ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">logStringStderr <span class="fu">=</span> <span class="dt">LogAction</span> <span class="fu">$</span> hPutStrLn stderr</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="ot">logStringBoth ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">logStringBoth <span class="fu">=</span> logStringStdout <span class="fu">&lt;&gt;</span> logStringStderr</a></code></pre></div>
<h3 id="monoid"><a href="#monoid">Monoid</a></h3>
<p>The <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Monoid"><code>Monoid</code></a> instance is even simpler:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">LogAction</span> m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">    mempty ::</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    mempty <span class="fu">=</span> <span class="dt">LogAction</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> pure ()</a></code></pre></div>
<p>It adds the empty <code>LogAction</code> that does nothing to the <code>Semigroup</code> instance. It’s quite straightforward to show that the above instances satisfy associativity and neutrality laws. The nice thing about the <code>Monoid</code> instance is the ability to disable logging. Usually, logging libraries provide some extra transformer with a name like <code>NoLoggingT</code> which you can put on top of your monad transformer tower to disable logging. But with a <code>Monoid</code> instance for <code>LogAction</code> you can just pass <code>mempty</code> as your logging action and that’s all. This approach also works quite well if you want to disable logging only in some specific piece of your code.</p>
<h2 id="contravariant-functors"><a href="#contravariant-functors">Contravariant functors</a></h2>
<p>This section covers the contravariant family of typeclasses regarding <code>LogAction</code>. The typeclasses themselves are implemented in the <a href="https://hackage.haskell.org/package/contravariant"><code>contravariant</code></a> package. This section assumes some basic knowledge for Contravariant functors, if you’re not familiar with them, I strongly recommend watching the following talk by George Wilson:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=IJ_bVVsQhvc">YOW! Lambda Jam 2018 - George Wilson - Contravariant Functors: The Other Side of the Coin</a></li>
</ul>
<h3 id="contravariant"><a href="#contravariant">Contravariant</a></h3>
<h4 id="map"><a href="#map">map</a></h4>
<p>Let’s first have a look at <code>Contravariant</code> typeclass and its instance for <code>LogAction</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">    contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">LogAction</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">    contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m b <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    contramap f (<span class="dt">LogAction</span> action) <span class="fu">=</span> <span class="dt">LogAction</span> (action <span class="fu">.</span> f)</a></code></pre></div>
<p>Here is how you can think of this instance: if you know how to log messages of type <code>b</code> and you know how to convert messages of type <code>a</code> to type <code>b</code>, then you also know how to log messages of type <code>a</code>. You just need to convert the <code>a</code> message to <code>b</code> and pass it to your action.</p>
<p>Here is an example of how it can be useful. Let’s say that instead of just logging <code>String</code>, you want to log a more complex <code>Message</code> data type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Severity</span> <span class="fu">=</span> <span class="dt">Debug</span> <span class="fu">|</span> <span class="dt">Info</span> <span class="fu">|</span> <span class="dt">Warning</span> <span class="fu">|</span> <span class="dt">Error</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Message</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    {<span class="ot"> messageSeverity ::</span> <span class="dt">Severity</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    ,<span class="ot"> messageText     ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    }</a></code></pre></div>
<p>But you only have <code>LogAction</code> that prints <code>String</code>. This is no longer a problem! You can write the formatting function:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">fmtMessage ::</span> <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">fmtMessage (<span class="dt">Message</span> sev txt) <span class="fu">=</span> “[“ <span class="fu">++</span> show sev <span class="fu">++</span> “] “ <span class="fu">++</span> txt</a></code></pre></div>
<p>And then you can use <code>contramap</code> to log messages instead of <code>String</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">log<span class="ot"> ::</span> <span class="dt">WithLog</span> env <span class="dt">Message</span> m <span class="ot">=&gt;</span> <span class="dt">Severity</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">log sev txt <span class="fu">=</span> logMsg (<span class="dt">Message</span> sev txt)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">example ::</span> <span class="dt">WithLog</span> env <span class="dt">Message</span> m <span class="ot">=&gt;</span> m ()</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">example <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    log <span class="dt">Debug</span> “<span class="dt">Starting</span> application<span class="fu">...</span>”</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    log <span class="dt">Info</span>  “<span class="dt">Finishing</span> application<span class="fu">...</span>”</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">main <span class="fu">=</span> usingLoggerT (contramap fmtMessage logStringStdout) example</a></code></pre></div>
<p>The output is the following:</p>
<pre class="shell"><code>[Debug] Starting application...
[Info] Finishing application...</code></pre>
<p>The problem of showing the output is handled separately from the problem of providing the input to the loggers. If you want to format the output in a different way (as JSON for example) you can just switch the formatting function to a different one.</p>
<h4 id="filter"><a href="#filter">filter</a></h4>
<p>Okay, now we would like to discard any <code>Debug</code> messages from the output. It’s easy to do after writing a contravariant filter function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">cfilter ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (msg <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m msg <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m msg</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">cfilter p (<span class="dt">LogAction</span> action) <span class="fu">=</span> <span class="dt">LogAction</span> <span class="fu">$</span> \a <span class="ot">-&gt;</span> when (p a) (action a)</a></code></pre></div>
<p>Now you can filter out all the <code>Debug</code> messages in the following way:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">main <span class="fu">=</span> usingLoggerT</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    ( cfilter (\(<span class="dt">Message</span> sev _) <span class="ot">-&gt;</span> sev <span class="fu">&gt;</span> <span class="dt">Debug</span>)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="fu">$</span> contramap fmtMessage logStringStdout</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    )</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    example</a></code></pre></div>
<h4 id="bind"><a href="#bind">bind</a></h4>
<p>There’s even more! We’re not satisfied with printing only <code>Severity</code> of the message. We would like to print the timestamp of the logging message as well. This is very useful for further log analysis. But with <code>contramap</code> we can’t do that because taking the current time is an impure function. So let’s implement <code>cbind</code> function and see how it helps:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">cbind ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m b <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">cbind f (<span class="dt">LogAction</span> action) <span class="fu">=</span> <span class="dt">LogAction</span> (f <span class="fu">&gt;=&gt;</span> action)</a></code></pre></div>
<p>Look at how similar it is to <code>contramap</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">contramap f (<span class="dt">LogAction</span> action) <span class="fu">=</span> <span class="dt">LogAction</span> (action  <span class="fu">.</span>  f)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">cbind     f (<span class="dt">LogAction</span> action) <span class="fu">=</span> <span class="dt">LogAction</span> (action <span class="fu">&lt;=&lt;</span> f)</a></code></pre></div>
<p>Now we can extend our <code>Message</code> data to <code>RichMesssage</code> that also stores <code>UTCTime</code> in it.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RichMessage</span> <span class="fu">=</span> <span class="dt">RichMessage</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">    {<span class="ot"> richMessageMsg  ::</span> <span class="dt">Message</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    ,<span class="ot"> richMessageTime ::</span> <span class="dt">UTCTime</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    }</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">makeRich ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">RichMessage</span> <span class="ot">-&gt;</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">Message</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">makeRich <span class="fu">=</span> cbind toRichMessage</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="ot">    toRichMessage ::</span> <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">RichMessage</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    toRichMessage msg <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">        time <span class="ot">&lt;-</span> getCurrentTime</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">        pure <span class="fu">$</span> <span class="dt">RichMessage</span> msg time</a></code></pre></div>
<p>After writing the formatting function for <code>RichMessage</code> we can enjoy an automatically appended timestamp to every message!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">main <span class="fu">=</span> usingLoggerT</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    (makeRich <span class="fu">$</span> contramap fmtRichMessage logStringStdout)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    example</a></code></pre></div>
<p>And now we have a more verbose output:</p>
<pre class="shell"><code>[Info] [11:54:31.809 13 Sep 2018 UTC] Finishing application...</code></pre>
<h3 id="divisible"><a href="#divisible">Divisible</a></h3>
<p>The Functor-Applicative-Alternative family of typeclasses is well-known to most Haskellers. But there are similar typeclasses for contravariant data types. Specifically, Contravariant-Divisible-Decidable. Let’s look at the <code>Divisible</code> typeclass definition and its instance for <code>LogAction</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> <span class="dt">Divisible</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">    conquer ::</span> f a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="ot">    divide  ::</span> (a <span class="ot">-&gt;</span> (b, c)) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">instance</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Divisible</span> (<span class="dt">LogAction</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="ot">    conquer ::</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">    conquer <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb25-9" data-line-number="9"></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"><span class="ot">    divide ::</span> (a <span class="ot">-&gt;</span> (b, c)) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m b <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m c <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    divide f (<span class="dt">LogAction</span> actionB) (<span class="dt">LogAction</span> actionC) <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">        <span class="dt">LogAction</span> <span class="fu">$</span> \(f <span class="ot">-&gt;</span> (b, c)) <span class="ot">-&gt;</span> actionB b <span class="fu">*&gt;</span> actionC c</a></code></pre></div>
<p>What this instance means is that if you know how to split some complex data structure into smaller pieces and if you know how to log each piece independently, you can now log the whole data structure.</p>
<h3 id="decidable"><a href="#decidable">Decidable</a></h3>
<p><code>Decidable</code> is similar to <code>Alternative</code> but for the Contravariant family of functors.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Void</span> (<span class="dt">Void</span>, absurd)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Divisible</span> f <span class="ot">=&gt;</span> <span class="dt">Decidable</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">  lose   ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Void</span>) <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="ot">  choose ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Either</span> b c) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Decidable</span> (<span class="dt">LogAction</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8"><span class="ot">    lose ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Void</span>) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">    lose f <span class="fu">=</span> <span class="dt">LogAction</span> (absurd <span class="fu">.</span> f)</a>
<a class="sourceLine" id="cb26-10" data-line-number="10"></a>
<a class="sourceLine" id="cb26-11" data-line-number="11"><span class="ot">    choose ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Either</span> b c) <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m b <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m c <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m a</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    choose f (<span class="dt">LogAction</span> actionB) (<span class="dt">LogAction</span> actionC) <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">        <span class="dt">LogAction</span> (either actionB actionC <span class="fu">.</span> f)</a></code></pre></div>
<p>The meaning of the <code>Decidable</code> instance for <code>LogAction</code> is that you can look at your logging message and decide what exactly you want to log. And if you know how to log every decision independently, you then can log the message.</p>
<h2 id="combinators"><a href="#combinators">Combinators</a></h2>
<p>Using the above instances and combinators from the <code>co-log</code> library, we can now have a combinatorial logging library.</p>
<p>Let’s first introduce the data types we want to log:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Engine</span> <span class="fu">=</span> <span class="dt">Pistons</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Rocket</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Car</span> <span class="fu">=</span> <span class="dt">Car</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    {<span class="ot"> carMake   ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    ,<span class="ot"> carModel  ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    ,<span class="ot"> carEngine ::</span> <span class="dt">Engine</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    }</a></code></pre></div>
<p>We also need couple helper functions in order to use the contravariant combinators:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">engineToEither ::</span> <span class="dt">Engine</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Int</span> ()</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">engineToEither e <span class="fu">=</span> <span class="kw">case</span> e <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="dt">Pistons</span> i <span class="ot">-&gt;</span> <span class="dt">Left</span> i</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="dt">Rocket</span>    <span class="ot">-&gt;</span> <span class="dt">Right</span> ()</a>
<a class="sourceLine" id="cb28-5" data-line-number="5"></a>
<a class="sourceLine" id="cb28-6" data-line-number="6"><span class="ot">carToTuple ::</span> <span class="dt">Car</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, (<span class="dt">String</span>, <span class="dt">Engine</span>))</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">carToTuple (<span class="dt">Car</span> make model engine) <span class="fu">=</span> (make, (model, engine))</a></code></pre></div>
<p>Then we’re going to introduce some basic logging actions:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">stringL ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">stringL <span class="fu">=</span> logStringStdout</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="co">-- Combinator that allows to log any showable value</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="ot">showL ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">LogAction</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">showL <span class="fu">=</span> cmap show stringL</a>
<a class="sourceLine" id="cb29-7" data-line-number="7"></a>
<a class="sourceLine" id="cb29-8" data-line-number="8"><span class="co">-- Returns a log action that logs a given string ignoring its input.</span></a>
<a class="sourceLine" id="cb29-9" data-line-number="9"><span class="ot">constL ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LogAction</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb29-10" data-line-number="10">constL s <span class="fu">=</span> s <span class="fu">&gt;$</span> stringL</a>
<a class="sourceLine" id="cb29-11" data-line-number="11"></a>
<a class="sourceLine" id="cb29-12" data-line-number="12"><span class="ot">intL ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13">intL <span class="fu">=</span> showL</a></code></pre></div>
<p>And then, we can add combinators:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">(&gt;$&lt;) ::</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="ot">(&gt;*&lt;) ::</span> <span class="dt">Divisible</span>     f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a, b)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="ot">(&gt;|&lt;) ::</span> <span class="dt">Decidable</span>     f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (<span class="dt">Either</span> a b)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="ot">(&gt;*)  ::</span> <span class="dt">Divisible</span>     f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"><span class="ot">(*&lt;)  ::</span> <span class="dt">Divisible</span>     f <span class="ot">=&gt;</span> f () <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>So we can log our <code>Car</code> data type in the following way:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">-- log action that logs a single car module</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">carL ::</span> <span class="dt">LogAction</span> <span class="dt">IO</span> <span class="dt">Car</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">carL <span class="fu">=</span> carToTuple</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="fu">&gt;$&lt;</span> (constL <span class="st">&quot;Logging make...&quot;</span> <span class="fu">*&lt;</span> stringL <span class="fu">&gt;*</span> constL <span class="st">&quot;Finished logging make...&quot;</span>)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    <span class="fu">&gt;*&lt;</span> (constL <span class="st">&quot;Logging model..&quot;</span> <span class="fu">*&lt;</span> stringL <span class="fu">&gt;*</span> constL <span class="st">&quot;Finished logging model...&quot;</span>)</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">    <span class="fu">&gt;*&lt;</span> ( engineToEither</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">      <span class="fu">&gt;$&lt;</span> constL <span class="st">&quot;Logging pistons...&quot;</span> <span class="fu">*&lt;</span> intL</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      <span class="fu">&gt;|&lt;</span> constL <span class="st">&quot;Logging rocket...&quot;</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">        )</a>
<a class="sourceLine" id="cb31-10" data-line-number="10"></a>
<a class="sourceLine" id="cb31-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">main <span class="fu">=</span> usingLoggerT carL <span class="fu">$</span> logMsg <span class="fu">$</span> <span class="dt">Car</span> <span class="st">&quot;Toyota&quot;</span> <span class="st">&quot;Corolla&quot;</span> (<span class="dt">Pistons</span> <span class="dv">4</span>)</a></code></pre></div>
<p>And the output is:</p>
<pre class="shell"><code>Logging make...
Toyota
Finished logging make...
Logging model..
Corolla
Finished logging model...
Logging pistons...
4</code></pre>
<p>This example might look not so convincing. But the approach becomes more useful when you want to log sophisticated data structures as it allows you to divide the message into smaller pieces and decide what to log.</p>
<h2 id="comonads"><a href="#comonads">Comonads</a></h2>
<p>Now, let’s talk about one of the most interesting parts of the <code>co-log</code> library. There is the <code>Comonad</code> typeclass which is dual to <code>Monad</code>. It’s implemented in the <a href="http://hackage.haskell.org/package/comonad"><code>comonad</code> package</a>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="ot">    extract ::</span> w a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="ot">    extend  ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</a></code></pre></div>
<p>And there’s a <code>Comonad</code> instance for the <code>Traced</code> data type:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Traced</span> m a <span class="fu">=</span> <span class="dt">Traced</span> {<span class="ot"> runTraced ::</span> m <span class="ot">-&gt;</span> a }</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Comonad</span> (<span class="dt">Traced</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="ot">    extract ::</span> <span class="dt">Traced</span> m a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    extract (<span class="dt">Traced</span> ma) <span class="fu">=</span> ma mempty</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="ot">    extend ::</span> (<span class="dt">Traced</span> m a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Traced</span> m a <span class="ot">-&gt;</span> <span class="dt">Traced</span> m b</a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    extend f (<span class="dt">Traced</span> ma) <span class="fu">=</span> <span class="dt">Traced</span> <span class="fu">$</span> \m <span class="ot">-&gt;</span> f <span class="fu">$</span> <span class="dt">Traced</span> <span class="fu">$</span> \m' <span class="ot">-&gt;</span> ma (m <span class="fu">&lt;&gt;</span> m')</a></code></pre></div>
<p>If you look closely at <code>Traced</code> data type, you might recognise similarities with <code>LogAction</code>. Indeed, <code>LogAction</code> can be defined as a special case of the <code>Traced</code> data type.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">type</span> <span class="dt">LogAction</span> m msg <span class="fu">=</span> <span class="dt">Traced</span> msg (m ())</a></code></pre></div>
<p>Since <code>LogAction</code> is just a special case of the <code>Traced</code> comonad, we can implement the <code>extract</code> and <code>extend</code> functions for <code>LogAction</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">extract ::</span> <span class="dt">Monoid</span> msg <span class="ot">=&gt;</span> <span class="dt">LogAction</span> m msg <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">extract (<span class="dt">LogAction</span> action) <span class="fu">=</span> action mempty</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">extend</a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="ot">    ::</span> <span class="dt">Semigroup</span> msg</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">    <span class="ot">=&gt;</span> (<span class="dt">LogAction</span> m msg <span class="ot">-&gt;</span> m ())</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m msg</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="ot">-&gt;</span> <span class="dt">LogAction</span> m msg</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">extend f (<span class="dt">LogAction</span> action) <span class="fu">=</span></a>
<a class="sourceLine" id="cb36-10" data-line-number="10">    <span class="dt">LogAction</span> <span class="fu">$</span> \m <span class="ot">-&gt;</span> f <span class="fu">$</span> <span class="dt">LogAction</span> <span class="fu">$</span> \m' <span class="ot">-&gt;</span> action (m <span class="fu">&lt;&gt;</span> m')</a></code></pre></div>
<p>Unfortunately, we can’t implement the <code>Comonad</code> instance for <code>LogAction</code> due to the interface mismatch. It would be possible only if <code>LogAction</code> was defined as a specialized version of the <code>Traced</code> comonad. However, by doing so we would lose other useful properties of defining <code>LogAction</code> as a separate newtype. However, we can still use the comonadic aspect of the <code>LogAction</code> structure. Here is a couple of simple examples of <code>LogAction</code> comonad usage:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1">ghci<span class="fu">&gt;</span> logToStdout <span class="fu">=</span> <span class="dt">LogAction</span> putStrLn</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">ghci<span class="fu">&gt;</span> f (<span class="dt">LogAction</span> l) <span class="fu">=</span> l <span class="st">&quot;.f1&quot;</span> <span class="fu">*&gt;</span> l <span class="st">&quot;.f2&quot;</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">ghci<span class="fu">&gt;</span> g (<span class="dt">LogAction</span> l) <span class="fu">=</span> l <span class="st">&quot;.g&quot;</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">ghci<span class="fu">&gt;</span> unLogAction logToStdout <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">foo</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">ghci<span class="fu">&gt;</span> unLogAction (extend f logToStdout) <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">foo<span class="fu">.</span>f1</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">foo<span class="fu">.</span>f2</a>
<a class="sourceLine" id="cb37-9" data-line-number="9">ghci<span class="fu">&gt;</span> unLogAction (extend g <span class="fu">$</span> extend f logToStdout) <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb37-10" data-line-number="10">foo<span class="fu">.</span>g<span class="fu">.</span>f1</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">foo<span class="fu">.</span>g<span class="fu">.</span>f2</a></code></pre></div>
<p>What this comonadic aspect of the interface means is that you can extend the existing <code>LogAction</code> by passing an additional payload to every message. This only works if your message is a <code>Semigroup</code> (or <code>Monoid</code>) and preferably a commutative <code>Semigroup</code> (or <code>Monoid</code>). For example, <code>Map String String</code>. If you log key-value pairs, you might want to add additional entries depending on the local context. Turns out this is extremely useful for structured logging: if you log JSON values, you might want to add extra keys or tags or values for specific functions and here is where the comonadic interface becomes helpful.</p>
<h2 id="configurable-convenient"><a href="#configurable-convenient">Configurable &amp; Convenient</a></h2>
<p>This section covers how dependent map, type-level programming and the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-labels"><code>-XOverloadedLabels</code> language extension</a> are used to implement a flexible and extensible interface for logging configuration.</p>
<p>Earlier I’ve introduced the <code>RichMessage</code> data type that allows to extend a simple <code>Message</code> with the result of an IO action:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RichMessage</span> <span class="fu">=</span> <span class="dt">RichMessage</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">    {<span class="ot"> richMessageMsg  ::</span> <span class="dt">Message</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    ,<span class="ot"> richMessageTime ::</span> <span class="dt">UTCTime</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    }</a></code></pre></div>
<p>Currently, it stores only the timestamp of the logged message. But in real life we might want to display more information on every logging message:</p>
<ul>
<li>Id of the current thread</li>
<li>Id of the current process</li>
<li>File size of the file where we currently write logs</li>
<li>Application memory usage</li>
<li>Number of currently active users (why not?)</li>
<li>Any other thing you can imagine</li>
</ul>
<p>If we only have a simple plain Haskell record we can’t easily extend it. Of course, you can always implement your own <code>RichMessage</code> and format in any way you want, but usually developers expect at least some configuration capabilities from a logging library. And configuring your output through boolean flags is not that convenient. That’s why <code>co-log</code> provides an extensible record interface to make it easier to add or remove some fields and I’m going to describe the implementation below.</p>
<p>The idea behind this solution is the following: let’s use some map to store the actions that extract the required information. So instead of specifying control options for some predefined set of possible message fields, we can just modify the map by adding or removing actions we want to execute on every call to the logging function. But since the actions might return values of different types, we need to use some dependent map.</p>
<p>The assumption here is that usually we configure logging for our application only once at the start of our application and then we only query those actions. So we need some map where construction and modification operations should be supported but their performance is not that important. The efficiency of the lookup function, on the other hand, should be quite high. Fortunately, there’s a structure that implements the required interface. The data structure itself is implemented in the <a href="https://github.com/kowainik/typerep-map"><code>typerep-map</code></a> package. If you want to learn about the implementation details of the <code>typerep-map</code> library, you can read the following blog post:</p>
<ul>
<li><a href="https://kowainik.github.io/posts/2018-07-11-typerep-map-step-by-step.html">Kowainik: typerep-map step by step</a></li>
</ul>
<p>We can build extensible records on top of the <code>typerep-map</code>, and I’m going to explain how it’s done in <code>co-log</code>.</p>
<p>First, let’s introduce a type family that maps arbitrary string tags to types.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">FieldType</span> (<span class="ot">fieldName ::</span> <span class="dt">Symbol</span>)<span class="ot"> ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldType</span> <span class="st">&quot;threadId&quot;</span> <span class="fu">=</span> <span class="dt">ThreadId</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldType</span> <span class="st">&quot;utcTime&quot;</span>  <span class="fu">=</span> <span class="dt">UTCTime</span></a></code></pre></div>
<p>The type family is open, so users can extend it with anything they want.</p>
<p>Now let’s introduce a data type that stores values of type <code>FieldType</code> inside some monad.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">MessageField</span> (<span class="ot">m ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">fieldName ::</span> <span class="dt">Symbol</span>) <span class="fu">=</span> <span class="dt">MessageField</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">    {<span class="ot"> unMesssageField ::</span> m (<span class="dt">FieldType</span> fieldName)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">    }</a></code></pre></div>
<p>We can now parametrize <code>TypeRepMap</code> with <code>MessageField</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">type</span> <span class="dt">FieldMap</span> (<span class="ot">m ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="fu">=</span> <span class="dt">TypeRepMap</span> (<span class="dt">MessageField</span> m)</a></code></pre></div>
<p>So <code>FieldMap</code> is a mapping from type level string to runtime value inside some monad <code>m</code>, where the type of the runtime value is defined by the value of the type-level string.</p>
<p>There is <a href="http://hackage.haskell.org/package/typerep-map-0.3.0/docs/Data-TypeRepMap.html#t:WrapTypeable">an existential wrapper</a> in the <code>typerep-map</code> library that allows to create <code>TypeRepMap</code> from a list due to <a href="http://hackage.haskell.org/package/typerep-map-0.3.0/docs/Data-TypeRepMap.html#t:TypeRepMap"><code>IsList</code> instance</a>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">defaultFieldMap ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FieldMap</span> m</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">defaultFieldMap <span class="fu">=</span> fromList</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">    [ <span class="dt">WrapTypeable</span> <span class="fu">$</span> <span class="dt">MessageField</span> <span class="fu">@</span>_ <span class="fu">@</span>”threadId” (liftIO myThreadId)</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">    , <span class="dt">WrapTypeable</span> <span class="fu">$</span> <span class="dt">MessageField</span> <span class="fu">@</span>_ <span class="fu">@</span>”utcTime”  (liftIO getCurrentTime)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">    ]</a></code></pre></div>
<p>Now we can extract monadic actions that return us values by doing <code>lookup @”threadId”</code>. Since it’s just a map, you can configure the output by putting additional actions in the map with the <code>insert</code> function or by removing some actions with the <code>delete</code> function. You only need to implement the formatting function for your <code>FieldMap</code> or use the default one from the <code>co-log</code> library.</p>
<p>But that’s not all. There’s the <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-OverloadedLabels.html"><code>OverloadedLabels</code> extension</a> since GHC 8.0.1 that allows us to specify such <code>FieldMap</code>s in a more convenient way. After writing the following instance:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">KnownSymbol</span> fieldName, a <span class="fu">~</span> m (<span class="dt">FieldType</span> fieldName))</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">      <span class="ot">=&gt;</span> <span class="dt">IsLabel</span> fieldName (a <span class="ot">-&gt;</span> <span class="dt">WrapTypeable</span> (<span class="dt">MessageField</span> m)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    fromLabel field <span class="fu">=</span> <span class="dt">WrapTypeable</span> <span class="fu">$</span> <span class="dt">MessageField</span> <span class="fu">@</span>_ <span class="fu">@</span>fieldName field</a></code></pre></div>
<p>The <code>OveloadedLabels</code> extension allows to write <code>#foo</code> instead of <code>fromLabel @”foo”</code>. So, by having the above instance for the function we can pass arguments to labels. We’re now able to define <code>defaultFieldMap</code> in a more concise way:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">defaultFieldMap ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FieldMap</span> m</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">defaultFieldMap <span class="fu">=</span> fromList</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">    [ <span class="fu">#</span>threadId (liftIO myThreadId)</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">    , <span class="fu">#</span>utcTime  (liftIO getCurrentTime)</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">    ]</a></code></pre></div>
<p>Here is how the output looks like with <code>ThreadId</code> and without it, for example from the library’s playground:</p>
<figure>
<img src="https://user-images.githubusercontent.com/4276606/45888166-fcbedb80-bdef-11e8-9a02-0e08cf30b6ab.png" alt="Logging example" /><figcaption>Logging example</figcaption>
</figure>
<p>The solution described above is currently implemented only for the <code>IO</code> part of the message extension. But there are plans to make the <code>Message</code> data type extensible as well (see issue below):</p>
<ul>
<li><a href="https://github.com/kowainik/co-log/issues/28">kowainik/co-log#issue-28</a></li>
</ul>
<h2 id="conclusion-unexplored-opportunities"><a href="#conclusion-unexplored-opportunities">Conclusion &amp; unexplored opportunities</a></h2>
<p>The <code>LogAction</code> data type is very simple on its own, but together with different instances, it brings a lot of power:</p>
<ul>
<li><code>Semigroup</code>: perform multiple actions for the same message</li>
<li><code>Monoid</code>: the action that does nothing</li>
<li><code>Contravariant</code>: the ability to consume action of the different type</li>
<li><code>Divisible</code>: log both types of messages if you know how to log all of them</li>
<li><code>Decidable</code>: decide what to log depending on the message</li>
<li><code>Comonad</code>: add an extra monoidal payload to message possibly using context</li>
</ul>
<p>There’s also the <a href="https://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad.html#t:ComonadApply"><code>ComonadApply</code></a> typeclass which purpose in application to <code>LogAction</code> is yet to be explored. And it would be really great to implement different logging backends for the <code>co-log</code> library (ElasticSearch, PostgreSQL, etc.).</p>
<h2 id="acknowledgement"><a href="#acknowledgement">Acknowledgement</a></h2>
<p>If you want to play with this approach in <a href="http://www.purescript.org/">PureScript</a>, there is a library that implements a similar idea:</p>
<ul>
<li><a href="https://github.com/rightfold/purescript-logging">rightfold/purescript-logging</a></li>
</ul>
              </p>
              </div>
          </div>
          </div>


      </div>


      <!-- Bootstrap core JavaScript -->
      <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"> </script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
      <script src="https://cdn.rawgit.com/icons8/bower-webicon/v0.10.7/jquery-webicon.min.js"></script>
      <script>hljs.initHighlightingOnLoad()</script>
      <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/contrib/auto-render.min.js"></script>
      <script async defer src="https://buttons.github.io/buttons.js"></script>
  </body>
</html>
