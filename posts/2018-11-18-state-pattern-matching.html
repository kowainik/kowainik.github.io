<!DOCTYPE html>
<html lang="en">
  <head>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125893749-1"></script>
      <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-125893749-1');
          </script>
    <title>State monad comes to help sequential pattern matching</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Kowainik page">
    <meta name="keywords" content="Haskell, Functional progarmming, FP">
    <meta name="author" content="Kowainik" />

    <!-- Twitter cards -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@kowainik" />
    <meta property="twitter:title" content="Kowainik - State monad comes to help sequential pattern matching" />
    <meta property="og:title" content="Kowainik - State monad comes to help sequential pattern matching" />
    <!-- <meta property="og:description" content="..." /> -->
    <meta property="og:site_name" content="Kowainik" />
    <meta property="og:image" content="https://kowainik.github.io/images/logo_trans.png" />

    <!-- Favicon -->
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" rel="stylesheet">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/dracula.min.css" />
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css">
    <!-- Custom fonts for this template -->
    <link href="../css/font-awesome.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Plugin CSS -->
    <link href="../css/magnific-popup.css" rel="stylesheet" type="text/css">
    <!-- Custom styles for this template -->
    <link href="../css/default.css" rel="stylesheet">
    <link href="../css/post.css" rel="stylesheet">
  </head>

  <body>

          <!-- Header -->
      <nav class="navbar navbar-inverse navbar-fixed-left leftmenu bg-primary text-secondary">
            <div class="navbar-header">
                <div class="postslogo"> <a class="navbar-brand" href="../"><img class="img-fluid d-block mx-auto" src="../images/logo-tr.png" alt="Kowainik"></a></div>
            </div>
            <div class="toc-zone">
                <h6 class="coolFont">Contents</h6>

                <div class="toc">
                    <ul> <li><a href="#problem">Problem</a></li><li><a href="#naive-solution">Naive solution</a></li><li><a href="#parsing-a-single-value">Parsing a single value</a></li><li><a href="#parsing-a-list-of-values-state">Parsing a list of values: State</a></li><li><a href="#parsing-a-list-of-values-statet-either">Parsing a list of values: StateT + Either</a></li></ul>
                </div>
            </div>
            <div class="coolFont">
                <div>Date: November 18, 2018</div>

                <div class="author">Author: Dmitrii Kovanikov</div>
                <div class="row tag-block">
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/haskell">haskell</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/state">state</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/transformers">transformers</a></span>
                
                </div>

                <div class="allposts">
                    <h3><a href="../posts"> Posts =<< </a></h3>
                </div>
            </div>
      </nav>
      <div class="container info">
          <h2 class="text-center text-uppercase text-secondary">State monad comes to help sequential pattern matching</h2>
          <div class="content">
          <div class="row post">
              <div class="col-12 post-body">
              <p class="lead">
                  <p>Let’s try to solve one specific problem using the <code>State</code> monad and monad transformers to see how pure stateful computations work in Haskell and how they can be used to write better interfaces. This blog post shouldn’t be considered as a tutorial on the <code>State</code> monad or monad transformers, but if you’re already familiar with those concepts, you may find the following use case interesting.</p>
<p>The blog post also contains several exercises, so you can follow the code by yourself and try to expand the presented solution along with solving exercises.</p>
<h2 id="problem"><a href="#problem">Problem</a></h2>
<p>Consider the following data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Value</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">BoolValue</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">IntValue</span> <span class="dt">Int</span></a></code></pre></div>
<p>This is a plain Haskell sum type that represents possible options of parsing the string into a more structured type.</p>
<blockquote>
<p><strong>NOTE:</strong> how to parse a string into a <code>Value</code> is out of the scope of this blog post.</p>
</blockquote>
<p>Let’s assume that you received a list of such values from some external data source and you want to convert this list to your custom data type. More precisely, you want to implement the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">decodeValues ::</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">VeryGoodErrorMessage</span> <span class="dt">MyType</span></a></code></pre></div>
<p>The need for such a function may appear in various situations. The list of <code>Value</code>s can represent many things:</p>
<ol type="1">
<li>A row in some CSV file.</li>
<li>A row in some SQL query result.</li>
<li>An array in some JSON object.</li>
</ol>
<p>Basically, any form of unstructured data that you want to decode to structured types.</p>
<p>I’m going to describe in detail, a possible general solution for implementing <code>decodeValues</code> with an explanatory error message.</p>
<h2 id="naive-solution"><a href="#naive-solution">Naive solution</a></h2>
<p>Suppose that you have this Haskell data type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    {<span class="ot"> userAge         ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    ,<span class="ot"> userIsHaskeller ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    }</a></code></pre></div>
<p>It’s quite easy to implement a naive decoder from <code>[Value]</code> to <code>User</code> with a poor error message:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">decodeValues ::</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">decodeValues [<span class="dt">IntValue</span> age, <span class="dt">BoolValue</span> hask] <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">User</span> age hask</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">decodeValues _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>This function is elementary and only uses basic pattern matching to convert a list of unstructured data to a custom Haskell data type. Sadly, the error message is completely non-informative. Ideally, <code>Maybe</code> should only be used when your function can fail because of a single reason. However, in our case there are multiple possible failure scenarios for the <code>decodeValues</code> function:</p>
<ol type="1">
<li>Given list is too small.</li>
<li>Given list is too big.</li>
<li><code>Value</code> at any index is different from what we expect.</li>
</ol>
<p>It would be tedious to implement good error reporting using only basic pattern matching. Moreover, the size of the function wouldn’t be small, which would and up being a problem when you need to write variations of your function for different types.</p>
<blockquote>
<p><strong>Exercise:</strong> try to implement the <code>decodeValues</code> function for <code>User</code> that reports good error messages and uses only pattern matching.</p>
</blockquote>
<p>The following sections of the blog post show a general solution to this problem with fine-grained error messages.</p>
<h2 id="parsing-a-single-value"><a href="#parsing-a-single-value">Parsing a single value</a></h2>
<p>First of all, like any other good Haskeller, I am going to decompose this huge problem into a few smaller ones. In the previous section, we started from decoding whole list of values, but let’s now learn how to decode a single value. Before that, however, we need to think about the data type of the error message. To have a clear understanding of what’s wrong with a single value, we need to know what the received value was and what we expected it to be:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">SingleValueError</span> <span class="fu">=</span> <span class="dt">SingleValueError</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    {<span class="ot"> singleValueErrorExpected ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    ,<span class="ot"> singleValueErrorActual   ::</span> <span class="dt">Value</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    }</a></code></pre></div>
<p>With that, we can implement functions for decoding a single <code>Value</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">valToBool ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">valToBool (<span class="dt">BoolValue</span> b) <span class="fu">=</span> <span class="dt">Right</span> b</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">valToBool v <span class="fu">=</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">SingleValueError</span> “<span class="dt">Bool</span>” v</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">valToInt ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">valToInt (<span class="dt">IntValue</span> i) <span class="fu">=</span> <span class="dt">Right</span> i</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">valToInt v <span class="fu">=</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">SingleValueError</span> “<span class="dt">Int</span>” v</a></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> we can remove some code duplication already at this stage! If you have a function like <code>typeName :: Typeable a =&gt; Text</code> (see <a href="http://hackage.haskell.org/package/relude-0.4.0/docs/Relude-Extra-Type.html#v:typeName">the implementation here</a>) and you derive prisms for the <code>Value</code> data type, you can implement a single generic <code>fromValue</code> function. But for the sake of simplicity, we won’t mind a bit of boilerplate code.</p>
</blockquote>
<p>Once we’ve learned how to decode a single value, let’s proceed with expanding this approach for a list of values.</p>
<h2 id="parsing-a-list-of-values-state"><a href="#parsing-a-list-of-values-state">Parsing a list of values: State</a></h2>
<p>Just like in the previous section, let’s start with creating the data type for our error messages:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListValueError</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">UnexpectedEndOfList</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">ExpectedEndOfList</span> (<span class="dt">NonEmpty</span> <span class="dt">Value</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">WrongValue</span> <span class="dt">SingleValueError</span></a></code></pre></div>
<p>Let’s look closer at the constructors of this error messages data type:</p>
<ol type="1">
<li><code>UnexpectedEndOfList</code>: this error means that the list was too short.</li>
<li><code>ExpectedEndOfList</code>: this error means that we were given a bigger list than we expected. This error contains the remaining <code>Value</code>s. Note that here we use a <code>NonEmpty</code> list to store the remaining items because if the list was bigger than we expected, then it’s guaranteed to have a non-empty remainder. This also prevents us from writing the wrong implementation of the function.</li>
<li><code>WrongValue</code>: this constructor stores the error for parsing a single value.</li>
</ol>
<p>The idea of using the <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-State-Strict.html"><code>State</code> monad</a> comes to mind after noticing the following: we can store the list of values in the state and in our stateful action we can decode the current head of the list and put the remaining list back to the state. Just as in basic <code>State</code> monad tutorials where a stack data structure is used as an example.</p>
<p>So, initially we should create the data type for our state:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Values</span> <span class="fu">=</span> <span class="dt">Values</span> {<span class="ot"> unValues ::</span> [<span class="dt">Value</span>] }</a></code></pre></div>
<p>That was easy. Now we need to specialize the <code>State</code> monad with our type and give it some meaningful name. We can use type aliases but let’s be good Haskellers and create the <code>newtype</code> as a wrapper around the <code>State</code> monad:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Decoder</span> a <span class="fu">=</span> <span class="dt">Decoder</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    {<span class="ot"> runDecoder ::</span> <span class="dt">State</span> <span class="dt">Values</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">Values</span>)</a></code></pre></div>
<p>Before writing the code itself, it makes sense to describe the logic behind the single value stateful decoder upfront:</p>
<ol type="1">
<li>We need to take a list of values from our state.</li>
<li>If the list is empty, we need to throw an error reporting that the list is empty and stop decoding.</li>
<li>If the list is not empty, we need to apply the given single value decoder to the head of the list and pattern match on the result of the decoder.</li>
<li>If the decoder results in error, we need to rethrow that error.</li>
<li>If the decoder is successful, we need to return our value and put the remaining list to the state.</li>
<li>Check the remaining list and if it’s not empty then throw the <code>ExpectedEndOfList</code> error.</li>
</ol>
<p>After designing our decoding algorithm, we can try to implement it:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">value</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> a)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Decoder</span> (<span class="dt">Either</span> <span class="dt">ListValueError</span> a)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">value valDecoder <span class="fu">=</span> gets unValues <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    [] <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Left</span> <span class="dt">UnexpectedEndOfList</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    val<span class="fu">:</span>vals <span class="ot">-&gt;</span> <span class="kw">case</span> valDecoder val <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">        <span class="dt">Left</span> err <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Left</span> <span class="dt">WrongValue</span> err</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">        <span class="dt">Right</span> a  <span class="ot">-&gt;</span> <span class="dt">Right</span> a <span class="fu">&lt;$</span> put (<span class="dt">Values</span> vals)</a></code></pre></div>
<blockquote>
<p><strong>Exercise:</strong> in our decoder for the field we don’t report the position of the <code>WrongField</code> error. However, it’s quite easy to patch the decoder to take this into consideration.</p>
</blockquote>
<p>We’re using <code>Either ListValueError</code> as a return type of our <code>value</code> decoder to report errors. But because of that, it’s not easy to compose different <code>value</code> decoders. This is how <code>Decoder</code> for <code>User</code> might look like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">user ::</span> <span class="dt">Decoder</span> (<span class="dt">Either</span> <span class="dt">ListValueError</span> <span class="dt">User</span>)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">user <span class="fu">=</span> value valToInt <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="dt">Left</span> err <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Left</span> err</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">Right</span> age <span class="ot">-&gt;</span> value valToBool <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">        <span class="dt">Left</span> err <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Left</span> err</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        <span class="dt">Right</span> hask <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">User</span> age hask</a></code></pre></div>
<p>In the last section, we are going to solve this particular problem: better composability of the value decoders.</p>
<h2 id="parsing-a-list-of-values-statet-either"><a href="#parsing-a-list-of-values-statet-either">Parsing a list of values: StateT + Either</a></h2>
<p>You may notice that the pattern matching we performed over <code>Either</code> looks familiar. Indeed, it is the <code>Monad</code> instance for <code>Either</code>. We couldn’t use it, because we were already using the <code>State</code> monad. This is the moment when monad transformers come to help. In simple words, with monad transformers we can combine monadic effects of multiple monads so the <code>&gt;&gt;=</code> operator performs actions for every monad in our monad transformer state.</p>
<p>We want to combine <code>State</code> and <code>Either</code> effects, but in this particular case, we should be cautious because the <code>State</code> monad transformer and the <code>Either</code> monad transformer don’t commute. Which means that <code>StateT s Either</code> is not the same as <code>EitherT (State s)</code>. Let’s look at this closely:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="dt">StateT</span> s m a <span class="fu">~</span> s <span class="ot">-&gt;</span> m (a, s)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="dt">EitherT</span> e m a <span class="fu">~</span> m (<span class="dt">Either</span> e a)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="dv">1</span><span class="fu">.</span> <span class="dt">StateT</span>  s (<span class="dt">Either</span> e) a <span class="fu">~</span>                        s <span class="ot">-&gt;</span> <span class="dt">Either</span> e (a, s)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="dv">2</span><span class="fu">.</span> <span class="dt">EitherT</span> e (<span class="dt">State</span>  s) a <span class="fu">~</span> <span class="dt">State</span> s (<span class="dt">Either</span> e a) <span class="fu">~</span> s <span class="ot">-&gt;</span> (<span class="dt">Either</span> e a, s)</a></code></pre></div>
<p>Today, let’s pick the first option. The reason for this is to stop decoding as soon as we faced an error. Only after we’ve managed to decode the raw values to our type successfully, we can inspect the remaining list of values in case we need to produce the <code>ExpectedEndOfList</code> error message.</p>
<p>Let’s refactor our existing approach to this new version, and start with patching the type of the <code>Decoder</code> monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Decoder</span> a <span class="fu">=</span> <span class="dt">Decoder</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    {<span class="ot"> runDecoder ::</span> <span class="dt">StateT</span> <span class="dt">Values</span> (<span class="dt">Either</span> <span class="dt">ListValueError</span>) a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    } <span class="kw">deriving</span> ( <span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">               , <span class="dt">MonadState</span> <span class="dt">Values</span>, <span class="dt">MonadError</span> <span class="dt">ListValueError</span>)</a></code></pre></div>
<p>Then we can rewrite our <code>value</code> decoder to use <code>throwError</code> function to report errors.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">value</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> a)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">value valDecoder <span class="fu">=</span> gets unValues <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    [] <span class="ot">-&gt;</span> throwError <span class="dt">UnexpectedEndOfList</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    val<span class="fu">:</span>vals <span class="ot">-&gt;</span> <span class="kw">case</span> valDecoder val <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwError <span class="fu">$</span> <span class="dt">WrongValue</span> err</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">        <span class="dt">Right</span> a  <span class="ot">-&gt;</span> a <span class="fu">&lt;$</span> put (<span class="dt">Values</span> vals)</a></code></pre></div>
<p>Note how cleaner the code became! Now it’s quite easy to implement the decoder for the <code>User</code> data type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">user ::</span> <span class="dt">Decoder</span> <span class="dt">User</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">user <span class="fu">=</span> <span class="dt">User</span> <span class="fu">&lt;$&gt;</span> value valToInt <span class="fu">&lt;*&gt;</span> value valToBool</a></code></pre></div>
<p>And it’s also straightforward to decode the list of values with the given <code>Decoder</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">decodeValues ::</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ListValueError</span> a</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">decodeValues values decoder <span class="fu">=</span> <span class="kw">do</span>  <span class="co">-- do-notation for the Either monad</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    (a, finalState) <span class="ot">&lt;-</span> runStateT (runDecoder decoder) (<span class="dt">Values</span> values)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    <span class="kw">case</span> unValues finalState <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">        []       <span class="ot">-&gt;</span> pure a</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">        val<span class="fu">:</span>vals <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">ExpectedEndOfList</span> (val <span class="fu">:|</span> vals)</a></code></pre></div>
<p>And it works like a charm:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">ghci<span class="fu">&gt;</span> decodeValues [] user</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="dt">Left</span> <span class="dt">UnexpectedEndOfList</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">ghci<span class="fu">&gt;</span> decodeValues [<span class="dt">IntValue</span> <span class="dv">42</span>, <span class="dt">BoolValue</span> <span class="dt">True</span>] user</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="dt">Right</span> (<span class="dt">User</span> {userAge <span class="fu">=</span> <span class="dv">42</span>, userIsHaskeller <span class="fu">=</span> <span class="dt">True</span>})</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">ghci<span class="fu">&gt;</span> decodeValues [<span class="dt">IntValue</span> <span class="dv">42</span>, <span class="dt">BoolValue</span> <span class="dt">True</span>] user</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="dt">Left</span> (<span class="dt">WrongValue</span> (<span class="dt">SingleValueError</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">    {valueErrorExpected <span class="fu">=</span> <span class="st">&quot;Int&quot;</span>, valueErrorActual <span class="fu">=</span> <span class="dt">BoolValue</span> <span class="dt">True</span>}))</a>
<a class="sourceLine" id="cb17-10" data-line-number="10"></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">ghci<span class="fu">&gt;</span> decodeValues [<span class="dt">IntValue</span> <span class="dv">42</span>, <span class="dt">BoolValue</span> <span class="dt">True</span>, <span class="dt">BoolValue</span> <span class="dt">False</span>] user</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"><span class="dt">Left</span> (<span class="dt">ExpectedEndOfList</span> (<span class="dt">BoolValue</span> <span class="dt">False</span> <span class="fu">:|</span> []))</a></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> In this blog post I’ve used function-based approach for decoders. However, it’s also possible to use typeclasses-based approach to avoid passing explicitly value conversion function for value decoder and <code>Decoder</code> action to <code>decodeValues</code> function.</p>
</blockquote>
<p>That’s all folks! I hope that after this blog post you gained a better insight into the <code>State</code> monad and monad transformers.</p>
<p>Here you can find gist with the full code:</p>
<ul>
<li><a href="https://gist.github.com/ChShersh/a608386180330c6b1eb07144f0a06815">Pattern matching + State monad + Monad transformers</a></li>
</ul>
              </p>
              </div>
          </div>
          </div>


      </div>


      <!-- Bootstrap core JavaScript -->
      <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"> </script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
      <script src="https://cdn.rawgit.com/icons8/bower-webicon/v0.10.7/jquery-webicon.min.js"></script>
      <script>hljs.initHighlightingOnLoad()</script>
      <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/contrib/auto-render.min.js"></script>
      <script async defer src="https://buttons.github.io/buttons.js"></script>
  </body>
</html>
