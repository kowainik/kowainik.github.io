<!DOCTYPE html>
<html lang="en">
  <head>
      <!-- Global site tag (gtag.js) - Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125893749-1"></script>
      <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-125893749-1');
          </script>
    <title>State monad comes to help sequential pattern matching :: Kowainik</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Kowainik â€” Combining Monad transformers and applicative functors for better error messages report">
    <meta name="keywords" content="Haskell, Functional progarmming, FP , haskell, state, transformers ">
    <meta name="author" content="Kowainik  â€” Dmitrii Kovanikov " />

    <!-- Twitter cards -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@kowainik" />
    <meta property="twitter:title" content="Kowainik - State monad comes to help sequential pattern matching" />
    <meta name="twitter:description" content="Combining Monad transformers and applicative functors for better error messages report" />
    <meta name="twitter:image:src" content="https://kowainik.github.io/images/logo-yellow.png" />
    <meta property="og:title" content="Kowainik - State monad comes to help sequential pattern matching" />
    <meta property="og:description" content="Combining Monad transformers and applicative functors for better error messages report" />
    <meta property="og:site_name" content="Kowainik" />
    <meta property="og:image" content="https://kowainik.github.io/images/logo-yellow.png" />

    <!-- Favicon -->
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/dracula.min.css" />
    <!-- Fontawesome -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
    <!-- Custom fonts for this template -->
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Lato" />
    <!-- Custom styles for this template -->
    <link href="../css/default.css" rel="stylesheet">
    <link href="../css/post.css" rel="stylesheet">
  </head>

  <body class="body-posts">

          <!-- Header -->
      <nav class="navbar navbar-inverse navbar-fixed-left leftmenu bg-primary text-secondary">
            <div class="navbar-header">
                <div class="postslogo"> <a class="navbar-brand" href="../"><img class="img-fluid" src="../images/logo-tr.png" alt="Kowainik"></a></div>

            </div>
            <div class="align-self-center">
                <a class="btn btn-primary rounded-pill" href="https://ko-fi.com/kowainik" target="_blank">
                    <i class="fas fa-coffee"></i> Buy a coffee
                </a>
            </div>

            <div class="toc-zone">
                <h6 class="coolFont">Contents</h6>
                <div class="toc" id="main">
                    <ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#naive-solution">Naive solution</a>
<ul>
<li><a href="#exercise-1">Exercise #1</a></li>
</ul></li>
<li><a href="#parsing-a-single-value">Parsing a single value</a></li>
<li><a href="#parsing-a-list-of-values-state">Parsing a list of values: State</a>
<ul>
<li><a href="#exercise-2">Exercise #2</a></li>
</ul></li>
<li><a href="#parsing-a-list-of-values-statet-either">Parsing a list of values: StateT + Either</a></li>
</ul>
                </div>
            </div>
            <div class="coolFont">
                <div>Date: November 18, 2018</div>
                

                <div class="author">Author: Dmitrii Kovanikov</div>
                <div class="row tag-block">
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/haskell">haskell</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/state">state</a></span>
                
                <span class="tag-block"> <a class="btn btn-outline-dark btn-tag" href="../tags/transformers">transformers</a></span>
                
                </div>

                <div class="allposts">
                    <h3><a href="../posts"> Posts =<< </a></h3>
                </div>
            </div>
      </nav>
      <div class="container info">
          <h2 class="text-center text-uppercase text-secondary">State monad comes to help sequential pattern matching</h2>
          <div class="content">
          <div class="row post">
              <div class="col-12 post-body">
              <p class="lead">
                  <p>Letâ€™s try to solve one specific problem using the <code>State</code> monad and monad transformers to see how pure stateful computations work in Haskell and how they can be used to write better interfaces. This blog post shouldnâ€™t be considered as a tutorial on the <code>State</code> monad or monad transformers, but if youâ€™re already familiar with those concepts, you may find the following use case interesting.</p>
<p>The blog post also contains several exercises, so you can follow the code by yourself and try to expand the presented solution along with solving exercises.</p>
<h2 id="problem">Problem<a href="#problem" class="anchor">ðŸ”—</a></h2>
<p>Consider the following data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Value</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="ot">=</span> <span class="dt">BoolValue</span> <span class="dt">Bool</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">IntValue</span> <span class="dt">Int</span></span></code></pre></div>
<p>This is a plain Haskell sum type that represents possible options of parsing the string into a more structured type.</p>
<blockquote>
<p><strong>NOTE:</strong> how to parse a string into a <code>Value</code> is out of the scope of this blog post.</p>
</blockquote>
<p>Letâ€™s assume that you received a list of such values from some external data source and you want to convert this list to your custom data type. More precisely, you want to implement the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">decodeValues ::</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">VeryGoodErrorMessage</span> <span class="dt">MyType</span></span></code></pre></div>
<p>The need for such a function may appear in various situations. The list of <code>Value</code>s can represent many things:</p>
<ol type="1">
<li>A row in some CSV file.</li>
<li>A row in some SQL query result.</li>
<li>An array in some JSON object.</li>
</ol>
<p>Basically, any form of unstructured data that you want to decode to structured types.</p>
<p>Iâ€™m going to describe in detail, a possible general solution for implementing <code>decodeValues</code> with an explanatory error message.</p>
<h2 id="naive-solution">Naive solution<a href="#naive-solution" class="anchor">ðŸ”—</a></h2>
<p>Suppose that you have this Haskell data type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    {<span class="ot"> userAge         ::</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    ,<span class="ot"> userIsHaskeller ::</span> <span class="dt">Bool</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    }</span></code></pre></div>
<p>Itâ€™s quite easy to implement a naive decoder from <code>[Value]</code> to <code>User</code> with a poor error message:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">decodeValues ::</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">User</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>decodeValues [<span class="dt">IntValue</span> age, <span class="dt">BoolValue</span> hask] <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">User</span> age hask</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>decodeValues _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This function is elementary and only uses basic pattern matching to convert a list of unstructured data to a custom Haskell data type. Sadly, the error message is completely non-informative. Ideally, <code>Maybe</code> should only be used when your function can fail because of a single reason. However, in our case there are multiple possible failure scenarios for the <code>decodeValues</code> function:</p>
<ol type="1">
<li>Given list is too small.</li>
<li>Given list is too big.</li>
<li><code>Value</code> at any index is different from what we expect.</li>
</ol>
<p>It would be tedious to implement good error reporting using only basic pattern matching. Moreover, the size of the function wouldnâ€™t be small, which would and up being a problem when you need to write variations of your function for different types.</p>
<section id="exercise-1" class="exercise">
<h3>Exercise #1<a href="#exercise-1" class="anchor">ðŸ”—</a></h3>
<p>Try to implement the <code>decodeValues</code> function for <code>User</code> that reports good error messages and uses only pattern matching.</p>
</section>
<p>The following sections of the blog post show a general solution to this problem with fine-grained error messages.</p>
<h2 id="parsing-a-single-value">Parsing a single value<a href="#parsing-a-single-value" class="anchor">ðŸ”—</a></h2>
<p>First of all, like any other good Haskeller, I am going to decompose this huge problem into a few smaller ones. In the previous section, we started from decoding whole list of values, but letâ€™s now learn how to decode a single value. Before that, however, we need to think about the data type of the error message. To have a clear understanding of whatâ€™s wrong with a single value, we need to know what the received value was and what we expected it to be:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">SingleValueError</span> <span class="ot">=</span> <span class="dt">SingleValueError</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    {<span class="ot"> singleValueErrorExpected ::</span> <span class="dt">Text</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    ,<span class="ot"> singleValueErrorActual   ::</span> <span class="dt">Value</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    }</span></code></pre></div>
<p>With that, we can implement functions for decoding a single <code>Value</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">valToBool ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> <span class="dt">Bool</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>valToBool (<span class="dt">BoolValue</span> b) <span class="ot">=</span> <span class="dt">Right</span> b</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>valToBool v <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">SingleValueError</span> <span class="st">&quot;Bool&quot;</span> v</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="ot">valToInt ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> <span class="dt">Int</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>valToInt (<span class="dt">IntValue</span> i) <span class="ot">=</span> <span class="dt">Right</span> i</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>valToInt v <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">SingleValueError</span> <span class="st">&quot;Int&quot;</span> v</span></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> we can remove some code duplication already at this stage! If you have a function like <code>typeName :: Typeable a =&gt; Text</code> (see <a href="http://hackage.haskell.org/package/relude-0.4.0/docs/Relude-Extra-Type.html#v:typeName">the implementation here</a>) and you derive prisms for the <code>Value</code> data type, you can implement a single generic <code>fromValue</code> function. But for the sake of simplicity, we wonâ€™t mind a bit of boilerplate code.</p>
</blockquote>
<p>Once weâ€™ve learned how to decode a single value, letâ€™s proceed with expanding this approach for a list of values.</p>
<h2 id="parsing-a-list-of-values-state">Parsing a list of values: State<a href="#parsing-a-list-of-values-state" class="anchor">ðŸ”—</a></h2>
<p>Just like in the previous section, letâ€™s start with creating the data type for our error messages:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ListValueError</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="ot">=</span> <span class="dt">UnexpectedEndOfList</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">ExpectedEndOfList</span> (<span class="dt">NonEmpty</span> <span class="dt">Value</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="op">|</span> <span class="dt">WrongValue</span> <span class="dt">SingleValueError</span></span></code></pre></div>
<p>Letâ€™s look closer at the constructors of this error messages data type:</p>
<ol type="1">
<li><code>UnexpectedEndOfList</code>: this error means that the list was too short.</li>
<li><code>ExpectedEndOfList</code>: this error means that we were given a bigger list than we expected. This error contains the remaining <code>Value</code>s. Note that here we use a <code>NonEmpty</code> list to store the remaining items because if the list was bigger than we expected, then itâ€™s guaranteed to have a non-empty remainder. This also prevents us from writing the wrong implementation of the function.</li>
<li><code>WrongValue</code>: this constructor stores the error for parsing a single value.</li>
</ol>
<p>The idea of using the <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-State-Strict.html"><code>State</code> monad</a> comes to mind after noticing the following: we can store the list of values in the state and in our stateful action we can decode the current head of the list and put the remaining list back to the state. Just as in basic <code>State</code> monad tutorials where a stack data structure is used as an example.</p>
<p>So, initially we should create the data type for our state:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Values</span> <span class="ot">=</span> <span class="dt">Values</span> {<span class="ot"> unValues ::</span> [<span class="dt">Value</span>] }</span></code></pre></div>
<p>That was easy. Now we need to specialize the <code>State</code> monad with our type and give it some meaningful name. We can use type aliases but letâ€™s be good Haskellers and create the <code>newtype</code> as a wrapper around the <code>State</code> monad:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Decoder</span> a <span class="ot">=</span> <span class="dt">Decoder</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    {<span class="ot"> runDecoder ::</span> <span class="dt">State</span> <span class="dt">Values</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">Values</span>)</span></code></pre></div>
<p>Before writing the code itself, it makes sense to describe the logic behind the single value stateful decoder upfront:</p>
<ol type="1">
<li>We need to take a list of values from our state.</li>
<li>If the list is empty, we need to throw an error reporting that the list is empty and stop decoding.</li>
<li>If the list is not empty, we need to apply the given single value decoder to the head of the list and pattern match on the result of the decoder.</li>
<li>If the decoder results in error, we need to rethrow that error.</li>
<li>If the decoder is successful, we need to return our value and put the remaining list to the state.</li>
<li>Check the remaining list and if itâ€™s not empty then throw the <code>ExpectedEndOfList</code> error.</li>
</ol>
<p>After designing our decoding algorithm, we can try to implement it:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>value</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="ot">    ::</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> a)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Decoder</span> (<span class="dt">Either</span> <span class="dt">ListValueError</span> a)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>value valDecoder <span class="ot">=</span> gets unValues <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    [] <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Left</span> <span class="dt">UnexpectedEndOfList</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    val<span class="op">:</span>vals <span class="ot">-&gt;</span> <span class="kw">case</span> valDecoder val <span class="kw">of</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Left</span> <span class="dt">WrongValue</span> err</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>        <span class="dt">Right</span> a  <span class="ot">-&gt;</span> <span class="dt">Right</span> a <span class="op">&lt;$</span> put (<span class="dt">Values</span> vals)</span></code></pre></div>
<section id="exercise-2" class="exercise">
<h3>Exercise #2<a href="#exercise-2" class="anchor">ðŸ”—</a></h3>
<p>In our decoder for the field we donâ€™t report the position of the <code>WrongField</code> error. However, itâ€™s quite easy to patch the decoder to take this into consideration.</p>
</section>
<p>Weâ€™re using <code>Either ListValueError</code> as the return type of our <code>value</code> decoder to report errors. But because of that, itâ€™s not easy to compose different <code>value</code> decoders. This is how <code>Decoder</code> for <code>User</code> might look like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">user ::</span> <span class="dt">Decoder</span> (<span class="dt">Either</span> <span class="dt">ListValueError</span> <span class="dt">User</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>user <span class="ot">=</span> value valToInt <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Left</span> err</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span class="dt">Right</span> age <span class="ot">-&gt;</span> value valToBool <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Left</span> err</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>        <span class="dt">Right</span> hask <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">User</span> age hask</span></code></pre></div>
<p>In the last section, we are going to solve this particular problem: better composability of the value decoders.</p>
<h2 id="parsing-a-list-of-values-statet-either">Parsing a list of values: StateT + Either<a href="#parsing-a-list-of-values-statet-either" class="anchor">ðŸ”—</a></h2>
<p>You may notice that the pattern matching we performed over <code>Either</code> looks familiar. Indeed, it is the <code>Monad</code> instance for <code>Either</code>. We couldnâ€™t use it, because we were already using the <code>State</code> monad. This is when monad transformers come in to save the day! In simple words, with monad transformers we can combine monadic effects of multiple monads so the <code>&gt;&gt;=</code> operator performs actions for every monad in our monad transformer state.</p>
<p>We want to combine <code>State</code> and <code>Either</code> effects, but in this particular case, we should be cautious because the <code>State</code> monad transformer and the <code>Either</code> monad transformer are not commutative. Which means that <code>StateT s Either</code> is not the same as <code>EitherT (State s)</code>. Letâ€™s look at this closely:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="dt">StateT</span> s m a <span class="op">~</span> s <span class="ot">-&gt;</span> m (a, s)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="dt">EitherT</span> e m a <span class="op">~</span> m (<span class="dt">Either</span> e a)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="dv">1</span><span class="op">.</span> <span class="dt">StateT</span>  s (<span class="dt">Either</span> e) a <span class="op">~</span>                        s <span class="ot">-&gt;</span> <span class="dt">Either</span> e (a, s)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="dv">2</span><span class="op">.</span> <span class="dt">EitherT</span> e (<span class="dt">State</span>  s) a <span class="op">~</span> <span class="dt">State</span> s (<span class="dt">Either</span> e a) <span class="op">~</span> s <span class="ot">-&gt;</span> (<span class="dt">Either</span> e a, s)</span></code></pre></div>
<p>Today, letâ€™s pick the first option. The reason for this is to stop decoding as soon as we face an error. Only after weâ€™ve managed to decode the raw values to our type successfully, we can inspect the remaining list of values in case we need to produce the <code>ExpectedEndOfList</code> error message.</p>
<p>Letâ€™s refactor our existing approach to this new version, and start with patching the type of the <code>Decoder</code> monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Decoder</span> a <span class="ot">=</span> <span class="dt">Decoder</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    {<span class="ot"> runDecoder ::</span> <span class="dt">StateT</span> <span class="dt">Values</span> (<span class="dt">Either</span> <span class="dt">ListValueError</span>) a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    } <span class="kw">deriving</span> ( <span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>               , <span class="dt">MonadState</span> <span class="dt">Values</span>, <span class="dt">MonadError</span> <span class="dt">ListValueError</span>)</span></code></pre></div>
<p>Then we can rewrite our <code>value</code> decoder to use <code>throwError</code> function to report errors.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>value</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="ot">    ::</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">SingleValueError</span> a)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>value valDecoder <span class="ot">=</span> gets unValues <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    [] <span class="ot">-&gt;</span> throwError <span class="dt">UnexpectedEndOfList</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    val<span class="op">:</span>vals <span class="ot">-&gt;</span> <span class="kw">case</span> valDecoder val <span class="kw">of</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">WrongValue</span> err</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        <span class="dt">Right</span> a  <span class="ot">-&gt;</span> a <span class="op">&lt;$</span> put (<span class="dt">Values</span> vals)</span></code></pre></div>
<p>Note how the code became much cleaner! Now itâ€™s quite easy to implement the decoder for the <code>User</code> data type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">user ::</span> <span class="dt">Decoder</span> <span class="dt">User</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>user <span class="ot">=</span> <span class="dt">User</span> <span class="op">&lt;$&gt;</span> value valToInt <span class="op">&lt;*&gt;</span> value valToBool</span></code></pre></div>
<p>And itâ€™s also straightforward to decode the list of values with the given <code>Decoder</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">decodeValues ::</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ListValueError</span> a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>decodeValues values decoder <span class="ot">=</span> <span class="kw">do</span>  <span class="co">-- do-notation for the Either monad</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    (a, finalState) <span class="ot">&lt;-</span> runStateT (runDecoder decoder) (<span class="dt">Values</span> values)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="kw">case</span> unValues finalState <span class="kw">of</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>        []       <span class="ot">-&gt;</span> <span class="fu">pure</span> a</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>        val<span class="op">:</span>vals <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ExpectedEndOfList</span> (val <span class="op">:|</span> vals)</span></code></pre></div>
<p>And it works like a charm:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> decodeValues [] user</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="dt">Left</span> <span class="dt">UnexpectedEndOfList</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>ghci<span class="op">&gt;</span> decodeValues [<span class="dt">IntValue</span> <span class="dv">42</span>, <span class="dt">BoolValue</span> <span class="dt">True</span>] user</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="dt">Right</span> (<span class="dt">User</span> {userAge <span class="ot">=</span> <span class="dv">42</span>, userIsHaskeller <span class="ot">=</span> <span class="dt">True</span>})</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>ghci<span class="op">&gt;</span> decodeValues [<span class="dt">BoolValue</span> <span class="dt">True</span>, <span class="dt">IntValue</span> <span class="dv">42</span>]  user</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a><span class="dt">Left</span> (<span class="dt">WrongValue</span> (<span class="dt">SingleValueError</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    {valueErrorExpected <span class="ot">=</span> <span class="st">&quot;Int&quot;</span>, valueErrorActual <span class="ot">=</span> <span class="dt">BoolValue</span> <span class="dt">True</span>}))</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>ghci<span class="op">&gt;</span> decodeValues [<span class="dt">IntValue</span> <span class="dv">42</span>, <span class="dt">BoolValue</span> <span class="dt">True</span>, <span class="dt">BoolValue</span> <span class="dt">False</span>] user</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a><span class="dt">Left</span> (<span class="dt">ExpectedEndOfList</span> (<span class="dt">BoolValue</span> <span class="dt">False</span> <span class="op">:|</span> []))</span></code></pre></div>
<blockquote>
<p><strong>NOTE:</strong> In this blog post Iâ€™ve used a function-based approach for decoders. However, itâ€™s also possible to use a typeclasses-based approach to avoid passing explicitly value conversion function for value decoder and <code>Decoder</code> action to <code>decodeValues</code> function.</p>
</blockquote>
<p>Thatâ€™s all folks! I hope that after this blog post you have gained a better insight into the <code>State</code> monad and monad transformers.</p>
<p>Here you can find gist with the full code:</p>
<ul>
<li><a href="https://gist.github.com/ChShersh/a608386180330c6b1eb07144f0a06815">Pattern matching + State monad + Monad transformers</a></li>
</ul>
              </p>
              </div>
          </div>
          </div>
      </div>


      <!-- Bootstrap core JavaScript -->
      <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"> </script>
      <script src="../js/post.js"> </script>
      <script src="../js/hide.js"> </script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
      <script>hljs.initHighlightingOnLoad()</script>
      <script async defer src="https://buttons.github.io/buttons.js"></script>
  </body>
</html>
